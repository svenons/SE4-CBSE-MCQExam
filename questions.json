{
    "Lecture1: Component-Based Systems": [
        {
            "question": "What is a core characteristic of a software component?",
            "choices": ["A. Requires a main method", "B. Is always a class", "C. Is independently deployable with well-defined interfaces", "D. Must use object-oriented inheritance"],
            "answer": "C",
            "reason": "A component is a reusable, independently deployable software unit with well-defined interfaces."
        },
        {
            "question": "What does CBSE stand for?",
            "choices": ["A. Centralized Binary Software Engineering", "B. Component-Based Software Engineering", "C. Component Binary System Engineering", "D. Core-Based System Engineering"],
            "answer": "B",
            "reason": "CBSE stands for Component-Based Software Engineering, an approach that builds systems using pre-existing, reusable components."
        },
        {
            "question": "Which term describes dividing a system into independent, self-contained parts?",
            "choices": ["A. Reusability", "B. Modularity", "C. Encapsulation", "D. Composition"],
            "answer": "B",
            "reason": "Modularity refers to dividing a system into independent, self-contained components."
        },
        {
            "question": "What is the purpose of encapsulation in a component?",
            "choices": ["A. To expose internal data for easy access", "B. To prevent the component from being reused", "C. To hide internal details and expose only public interfaces", "D. To enforce use of object inheritance"],
            "answer": "C",
            "reason": "Encapsulation hides the internal details of a component and exposes only the public interfaces."
        },
        {
            "question": "What defines structure, behavior, and interaction standards of components?",
            "choices": ["A. Component Model", "B. Component Framework", "C. Component Repository", "D. Component Adapter"],
            "answer": "A",
            "reason": "A Component Model defines the structure, behavior, and interaction standards of components."
        },
        {
            "question": "Which architecture pattern uses small, independent services often deployed via containers?",
            "choices": ["A. Monolithic Architecture", "B. Microservices Architecture", "C. CORBA", "D. Client-Server Architecture"],
            "answer": "B",
            "reason": "Microservices Architecture uses small, independent services often deployed via containers (e.g., Docker, Kubernetes)."
        },
        {
            "question": "What does a Component Adapter do?",
            "choices": ["A. Stores components in a central database", "B. Bridges incompatible component interfaces", "C. Provides deployment specifications", "D. Defines the component model"],
            "answer": "B",
            "reason": "A Component Adapter is a software element that bridges incompatible component interfaces."
        },
        {
            "question": "In component composition, which type involves components being called one after another by an external application?",
            "choices": ["A. Additive Composition", "B. Hierarchical Composition", "C. Sequential Composition", "D. Parallel Composition"],
            "answer": "C",
            "reason": "Sequential Composition involves components being called in sequence by an external application."
        },
        {
            "question": "Which of the following is an obsolete framework for cross-platform component communication?",
            "choices": ["A. CORBA", "B. SOA", "C. Microservices", "D. REST"],
            "answer": "A",
            "reason": "CORBA (Common Object Request Broker Architecture) is an obsolete framework that enabled components to communicate across languages and platforms."
        },
        {
            "question": "How do components differ from objects?",
            "choices": ["A. Components are lower-level constructs than objects", "B. Objects are reusable across systems, components are not", "C. Components are higher-level, coarse-grained reusable modules; objects are fine-grained instances of classes", "D. There is no difference between components and objects"],
            "answer": "C",
            "reason": "Components are higher-level, coarse-grained reusable modules, while objects are fine-grained instances of classes."
        },
        {
            "question": "Which of the following is the main benefit of reusability in CBSE?",
            "choices": ["A. Increased code complexity", "B. Reduced system performance", "C. Faster development and lower costs", "D. Increased need for manual testing"],
            "answer": "C",
            "reason": "Reusability allows components to be used across multiple systems, resulting in faster development and lower costs."
        },
        {
            "question": "Which term describes the ability to combine components to form larger systems?",
            "choices": ["A. Adaptability", "B. Composability", "C. Encapsulation", "D. Modularization"],
            "answer": "B",
            "reason": "Composability refers to the ability to combine components to form larger systems."
        },
        {
            "question": "What does a Component Repository typically store?",
            "choices": ["A. Source code only", "B. Executable files only", "C. Components, their metadata, and interfaces", "D. Deployment logs"],
            "answer": "C",
            "reason": "A Component Repository stores components, their metadata, and interfaces."
        },
        {
            "question": "What is an example of a Component Repository mentioned in the lecture?",
            "choices": ["A. Docker Hub", "B. GitHub", "C. Maven Central Repository", "D. NPM"],
            "answer": "C",
            "reason": "Maven Central Repository is an example of a Component Repository."
        },
        {
            "question": "Which interface type specifies services a component offers?",
            "choices": ["A. Requires Interface", "B. Adapter Interface", "C. Provides Interface", "D. Hidden Interface"],
            "answer": "C",
            "reason": "Provides Interface specifies the services a component offers to others."
        },
        {
            "question": "Which interface type specifies services a component needs from other components?",
            "choices": ["A. Requires Interface", "B. Adapter Interface", "C. Provides Interface", "D. Implementation Interface"],
            "answer": "A",
            "reason": "Requires Interface specifies the services a component needs from others."
        },
        {
            "question": "In which type of component composition does one component directly call another?",
            "choices": ["A. Sequential Composition", "B. Hierarchical Composition", "C. Additive Composition", "D. Parallel Composition"],
            "answer": "B",
            "reason": "Hierarchical Composition involves one component directly calling another component."
        },
        {
            "question": "In Additive Composition, components:",
            "choices": ["A. Call each other directly", "B. Call each other sequentially", "C. Do not call each other and operate independently", "D. Must share the same interface"],
            "answer": "C",
            "reason": "In Additive Composition, components do not call each other and operate independently."
        },
        {
            "question": "Which architecture involves services as stand-alone entities communicating via standard protocols?",
            "choices": ["A. Monolithic Architecture", "B. Service-Oriented Architecture (SOA)", "C. Microkernel Architecture", "D. MVC Architecture"],
            "answer": "B",
            "reason": "Service-Oriented Architecture (SOA) involves stand-alone services communicating via standard protocols like SOAP and REST."
        },
        {
            "question": "Which of the following statements about CORBA is correct?",
            "choices": ["A. CORBA is a modern framework based on REST APIs", "B. CORBA uses Object Request Brokers and IIOP", "C. CORBA is required for Microservices", "D. CORBA is a proprietary Microsoft technology"],
            "answer": "B",
            "reason": "CORBA (Common Object Request Broker Architecture) used Object Request Brokers (ORBs) and the Internet Inter-ORB Protocol (IIOP)."
        },
                {
            "question": "Which of the following best describes the granularity of Objects compared to Components?",
            "choices": ["A. Objects are coarse-grained; Components are fine-grained", "B. Both Objects and Components are fine-grained", "C. Objects are fine-grained; Components are coarse-grained", "D. Both Objects and Components are coarse-grained"],
            "answer": "C",
            "reason": "Objects are fine-grained instances of classes; Components are higher-level, coarse-grained reusable modules."
        },
        {
            "question": "In which architecture are services typically stateless and independently deployable?",
            "choices": ["A. SOA", "B. Microservices", "C. CORBA", "D. Monolithic"],
            "answer": "B",
            "reason": "Microservices architecture uses small, independently deployable services that are often stateless."
        },
        {
            "question": "Which architecture commonly uses SOAP as a communication protocol?",
            "choices": ["A. Microservices", "B. Component Model", "C. SOA", "D. Object-Oriented"],
            "answer": "C",
            "reason": "Service-Oriented Architecture (SOA) often uses SOAP as a standard communication protocol."
        },
        {
            "question": "Which of the following is true about Components in comparison to Objects?",
            "choices": ["A. Components are runtime instances of classes", "B. Objects are deployed independently", "C. Components are deployed independently with well-defined interfaces", "D. Objects and Components are interchangeable"],
            "answer": "C",
            "reason": "Components are independently deployable software units with well-defined interfaces, unlike typical objects."
        },
        {
            "question": "Which architecture pattern is more likely to utilize containerization technologies such as Docker?",
            "choices": ["A. Object-Oriented Architecture", "B. SOA", "C. Monolithic Architecture", "D. Microservices Architecture"],
            "answer": "D",
            "reason": "Microservices Architecture commonly uses containerization technologies like Docker and orchestration tools like Kubernetes."
        },
        {
            "question": "Which element defines the standards for structure, behavior, and interaction of components?",
            "choices": ["A. Component Framework", "B. Component Adapter", "C. Component Model", "D. Microservice"],
            "answer": "C",
            "reason": "The Component Model defines the structure, behavior, and interaction standards for components."
        },
        {
            "question": "Which element provides the runtime environment and manages lifecycle of components?",
            "choices": ["A. Component Model", "B. Component Repository", "C. Component Framework", "D. Microservice"],
            "answer": "C",
            "reason": "A Component Framework provides the runtime environment for components and manages their lifecycle and communication."
        },
        {
            "question": "In terms of service composition, which architecture often involves orchestration via an Enterprise Service Bus (ESB)?",
            "choices": ["A. Object-Oriented Architecture", "B. Microservices", "C. SOA", "D. Component Framework"],
            "answer": "C",
            "reason": "SOA often uses an Enterprise Service Bus (ESB) for orchestrating and mediating services."
        },
        {
            "question": "Which architecture typically emphasizes loose coupling and decentralized governance?",
            "choices": ["A. Object-Oriented", "B. SOA", "C. Microservices", "D. Monolithic"],
            "answer": "C",
            "reason": "Microservices architecture emphasizes loose coupling, decentralized data management, and independent governance of services."
        },
        {
            "question": "Which architecture tends to involve larger, more complex service contracts and centralized control?",
            "choices": ["A. Microservices", "B. Component Framework", "C. SOA", "D. Object-Oriented"],
            "answer": "C",
            "reason": "SOA often involves larger and more complex service contracts and centralized control mechanisms like ESB."
        }
    ],
    "Lecture2: Java Crash Course & Introduction to Maven": [
        {
            "question": "Which component of the JVM is responsible for loading classes?",
            "choices": ["A. Execution Engine", "B. Class Loader", "C. JIT Compiler", "D. Garbage Collector"],
            "answer": "B",
            "reason": "The Class Loader in the JVM is responsible for loading classes."
        },
        {
            "question": "What is the primary purpose of the Java Virtual Machine (JVM)?",
            "choices": ["A. Compile Java source code", "B. Interpret HTML files", "C. Execute Java bytecode on any platform", "D. Manage database connections"],
            "answer": "C",
            "reason": "The JVM executes Java bytecode on any platform, enabling Java's platform independence."
        },
        {
            "question": "Which Java component provides both the JVM and core libraries but no development tools?",
            "choices": ["A. JDK", "B. JRE", "C. IDE", "D. JVM"],
            "answer": "B",
            "reason": "The JRE provides the JVM and core libraries but does not include development tools."
        },
        {
            "question": "Which pillar of Object-Oriented Programming involves hiding implementation details and exposing only essential features?",
            "choices": ["A. Inheritance", "B. Polymorphism", "C. Abstraction", "D. Encapsulation"],
            "answer": "C",
            "reason": "Abstraction hides implementation details and exposes only the essential features."
        },
        {
            "question": "Which Java keyword is used to define a class that cannot be instantiated directly?",
            "choices": ["A. interface", "B. static", "C. abstract", "D. final"],
            "answer": "C",
            "reason": "An abstract class cannot be instantiated directly and is used to define common behavior."
        },
        {
            "question": "Which keyword is used to indicate a method or variable is accessible everywhere?",
            "choices": ["A. private", "B. protected", "C. public", "D. package-private"],
            "answer": "C",
            "reason": "The public keyword makes a method or variable accessible from anywhere."
        },
        {
            "question": "What type of polymorphism is achieved through method overloading?",
            "choices": ["A. Runtime polymorphism", "B. Dynamic polymorphism", "C. Compile-time polymorphism", "D. Late binding polymorphism"],
            "answer": "C",
            "reason": "Method overloading achieves compile-time polymorphism."
        },
        {
            "question": "In Java, what is the purpose of the `finally` block in exception handling?",
            "choices": ["A. To catch exceptions", "B. To throw exceptions", "C. To always execute cleanup code", "D. To skip code execution"],
            "answer": "C",
            "reason": "The finally block is used to execute cleanup code that must run regardless of whether an exception is thrown."
        },
        {
            "question": "Which interface is part of the Java Collections Framework?",
            "choices": ["A. Map", "B. HashCode", "C. Thread", "D. Iterator"],
            "answer": "A",
            "reason": "Map is a core interface in the Java Collections Framework for storing key-value pairs."
        },
        {
            "question": "What is the purpose of using Generics in Java?",
            "choices": ["A. To improve runtime performance", "B. To enable dynamic typing", "C. To allow type-safe operations on various types", "D. To avoid using interfaces"],
            "answer": "C",
            "reason": "Generics enable type-safe operations on various types, allowing for reusable and flexible code."
        },
                {
            "question": "Which file defines project configuration in a Maven project?",
            "choices": ["A. pom.properties", "B. pom.xml", "C. build.gradle", "D. config.yaml"],
            "answer": "B",
            "reason": "Maven uses the POM (Project Object Model), defined in the pom.xml file, to configure the project."
        },
        {
            "question": "What does Maven's dependency management help developers achieve?",
            "choices": ["A. Writing unit tests", "B. Managing transitive dependencies", "C. Improving UI responsiveness", "D. Simplifying database configuration"],
            "answer": "B",
            "reason": "Maven’s dependency management helps automatically resolve and manage transitive dependencies across the project."
        },
        {
            "question": "Which Maven lifecycle phase compiles the source code?",
            "choices": ["A. validate", "B. test", "C. compile", "D. install"],
            "answer": "C",
            "reason": "The compile phase in Maven compiles the project’s source code."
        },
        {
            "question": "In which type of Maven repository are dependencies typically stored on a developer's machine?",
            "choices": ["A. Central", "B. Local", "C. Remote", "D. Cloud"],
            "answer": "B",
            "reason": "A local repository is stored on the developer's machine, typically under ~/.m2/repository."
        },
        {
            "question": "What is a Maven archetype?",
            "choices": ["A. A runtime dependency", "B. A static code analyzer", "C. A project template", "D. A test framework"],
            "answer": "C",
            "reason": "A Maven archetype is a project template used to quickly create pre-configured project structures."
        },
        {
            "question": "In Maven, what does the 'provided' dependency scope mean?",
            "choices": ["A. Dependency used only for unit tests", "B. Dependency available at compile/runtime", "C. Dependency provided by the runtime environment", "D. Dependency only available in production"],
            "answer": "C",
            "reason": "The 'provided' scope means the dependency will be provided by the runtime environment (e.g., servlet container or app server)."
        },
        {
            "question": "Which is a key benefit of using a Multi-Module Maven project?",
            "choices": ["A. Increases build time", "B. Reduces test coverage", "C. Encourages tight coupling", "D. Promotes modularity and separation of concerns"],
            "answer": "D",
            "reason": "A Multi-Module Maven project promotes modularity, separation of concerns, and efficient build management."
        },
        {
            "question": "How is component-based design different from inheritance-based design?",
            "choices": ["A. It uses class hierarchies", "B. It prefers composition over inheritance", "C. It requires multiple inheritance", "D. It avoids using interfaces"],
            "answer": "B",
            "reason": "Component-based design prefers composition over inheritance, resulting in looser coupling and more flexible design."
        },
        {
            "question": "Which concept helps automate component assembly in component-based Java systems?",
            "choices": ["A. Static imports", "B. Dependency Injection frameworks", "C. Singleton pattern", "D. Java Reflection"],
            "answer": "B",
            "reason": "Dependency Injection frameworks (e.g., Spring DI) help automate component assembly and promote loose coupling."
        },
        {
            "question": "In the context of component-based Java design, what is the purpose of the Whiteboard Component Model?",
            "choices": ["A. To implement static method calls", "B. To enable dynamic service registration and decoupling", "C. To replace dependency injection", "D. To enforce compile-time type checks"],
            "answer": "B",
            "reason": "The Whiteboard Component Model enables dynamic service registration and decoupling at runtime, enhancing flexibility."
        },
                {
            "question": "Which of the following is included in JDK but not in JRE?",
            "choices": ["A. JVM", "B. Java core libraries", "C. Development tools like javac", "D. Bytecode interpreter"],
            "answer": "C",
            "reason": "JDK includes JRE + development tools such as the Java compiler (javac), debugger (jdb), and others."
        },
        {
            "question": "Which of the following can be used to achieve multiple inheritance in Java?",
            "choices": ["A. Abstract classes", "B. Interfaces", "C. Regular classes", "D. Final classes"],
            "answer": "B",
            "reason": "Java does not support multiple inheritance with classes, but it can be achieved using interfaces."
        },
        {
            "question": "Which of the following is an advantage of Component-Based Design over Inheritance-Based Design?",
            "choices": ["A. Promotes tight coupling", "B. Reduces reusability", "C. Promotes loose coupling and flexibility", "D. Requires deep class hierarchies"],
            "answer": "C",
            "reason": "Component-Based Design promotes loose coupling and flexibility by favoring composition over inheritance."
        },
        {
            "question": "Compile-time polymorphism is achieved through which mechanism in Java?",
            "choices": ["A. Method overriding", "B. Method overloading", "C. Dynamic dispatch", "D. Interfaces"],
            "answer": "B",
            "reason": "Compile-time polymorphism in Java is achieved through method overloading."
        },
        {
            "question": "Runtime polymorphism is achieved through which mechanism in Java?",
            "choices": ["A. Method overloading", "B. Method overriding", "C. Constructor overloading", "D. Static binding"],
            "answer": "B",
            "reason": "Runtime polymorphism is achieved through method overriding, where the method call is resolved at runtime."
        },
        {
            "question": "Which keyword is used to declare an abstract class in Java?",
            "choices": ["A. static", "B. abstract", "C. interface", "D. final"],
            "answer": "B",
            "reason": "The 'abstract' keyword is used to declare an abstract class in Java."
        },
        {
            "question": "In terms of purpose, how does an Interface differ from an Abstract Class in Java?",
            "choices": ["A. Interfaces cannot have methods", "B. Abstract Classes can only define constants", "C. Interfaces define a contract; Abstract Classes provide partial implementation", "D. Both are used identically in all cases"],
            "answer": "C",
            "reason": "Interfaces define a contract without implementation; Abstract Classes can provide partial implementation."
        },
        {
            "question": "In component assembly, which model emphasizes dynamic service registration at runtime?",
            "choices": ["A. Dependency Injection", "B. Factory pattern", "C. Singleton pattern", "D. Whiteboard Component Model"],
            "answer": "D",
            "reason": "The Whiteboard Component Model emphasizes dynamic service registration and decoupling at runtime."
        },
        {
            "question": "In component assembly, which model emphasizes compile-time wiring of dependencies?",
            "choices": ["A. Whiteboard Component Model", "B. Dependency Injection", "C. Service Locator pattern", "D. Adapter pattern"],
            "answer": "B",
            "reason": "Dependency Injection emphasizes compile-time wiring of dependencies, often supported by DI frameworks such as Spring."
        },
        {
            "question": "Which is more flexible and suitable for designing highly decoupled systems?",
            "choices": ["A. Inheritance-Based Design", "B. Whiteboard Component Model", "C. Static imports", "D. Deep class hierarchy"],
            "answer": "B",
            "reason": "The Whiteboard Component Model enables dynamic registration and decoupling, making it suitable for flexible, highly decoupled systems."
        }
    ],
    "Lecture3: Component-Oriented Design & Architecture": [
        {
            "question": "Which characteristic of CBSE refers to the ability to use a component across multiple systems?",
            "choices": ["A. Modularity", "B. Encapsulation", "C. Reusability", "D. Maintainability"],
            "answer": "C",
            "reason": "Reusability refers to the ability to use components across multiple systems or projects."
        },
        {
            "question": "What is a primary effect of tight coupling?",
            "choices": ["A. Increased flexibility", "B. Easier testing", "C. Harder maintenance", "D. Reduced performance"],
            "answer": "C",
            "reason": "Tight coupling results in less flexibility and makes maintenance and testing more difficult."
        },
        {
            "question": "Loose coupling is commonly achieved using which technique?",
            "choices": ["A. Tight inheritance", "B. Multiple inheritance", "C. Dependency Injection", "D. Static methods"],
            "answer": "C",
            "reason": "Loose coupling is commonly achieved using Dependency Injection, which allows components to depend on interfaces rather than concrete implementations."
        },
        {
            "question": "What does a component with dependency depth 0 indicate?",
            "choices": ["A. It is a user interface component", "B. It has no dependencies", "C. It has one external dependency", "D. It must be recompiled frequently"],
            "answer": "B",
            "reason": "A component with dependency depth 0 has no dependencies."
        },
        {
            "question": "Which type of component dependency allows for greater flexibility at runtime?",
            "choices": ["A. Build-time dependency", "B. Compile-time dependency", "C. Static dependency", "D. Run-time dependency"],
            "answer": "D",
            "reason": "Run-time dependencies allow for more flexible systems since components can be assembled or replaced dynamically at runtime."
        },
        {
            "question": "In Layered Architecture, a common problem is:",
            "choices": ["A. Poor performance", "B. Tight coupling of business logic and UI", "C. Logical layers requiring full redeployment when one layer changes", "D. Inability to add new layers"],
            "answer": "C",
            "reason": "In Layered Architecture, logical layers are often tightly packaged, so redeploying one layer may require redeploying the whole application."
        },
        {
            "question": "What is a key benefit of Layered Component-Based Architecture compared to traditional Layered Architecture?",
            "choices": ["A. Reduced number of components", "B. Improved performance", "C. Components can be replaced independently", "D. Simpler UI design"],
            "answer": "C",
            "reason": "In Layered Component-Based Architecture, components can be replaced independently, providing better flexibility and maintainability."
        },
        {
            "question": "Which pattern uses a central registry for components to look up required services?",
            "choices": ["A. Dependency Injection", "B. Singleton", "C. Service Locator", "D. Factory Method"],
            "answer": "C",
            "reason": "The Service Locator pattern uses a central registry where components can look up required services."
        },
        {
            "question": "Which Java mechanism is used to package and distribute Java components?",
            "choices": ["A. WAR files", "B. JARs and Packages", "C. EAR files", "D. Docker containers"],
            "answer": "B",
            "reason": "JARs (Java ARchive files) and Packages are used to package and distribute Java components."
        },
        {
            "question": "What does a Provided Interface define in a component?",
            "choices": ["A. Services the component requires", "B. Services the component offers to others", "C. External services used by the component", "D. Services inherited from the parent class"],
            "answer": "B",
            "reason": "A Provided Interface defines the services that the component offers to other components."
        },
        {
            "question": "According to componentization rules, how should Entity classes typically be packaged?",
            "choices": ["A. As standalone components", "B. Inside a UI component", "C. In a shared base library", "D. Inside the database layer"],
            "answer": "C",
            "reason": "Entity classes should be packaged in a shared base library and not as standalone components."
        },
        {
            "question": "In an effective componentization strategy, how should business functionality be exposed?",
            "choices": ["A. By accessing class fields directly", "B. By using public static methods", "C. Through provided interfaces only", "D. Through internal utility classes"],
            "answer": "C",
            "reason": "Business functionality should be exposed through provided interfaces only, following the principle of encapsulation."
        },
        {
            "question": "What is a main purpose of using glue code in component-based design?",
            "choices": ["A. To hardcode dependencies", "B. To bridge runtime dependencies dynamically", "C. To compile multiple components together", "D. To optimize database queries"],
            "answer": "B",
            "reason": "Glue code is used to bridge runtime dependencies dynamically and facilitate loose coupling."
        },
        {
            "question": "Which component assembly model involves injecting dependencies at runtime?",
            "choices": ["A. Singleton", "B. Whiteboard", "C. Service Locator", "D. Dependency Injection"],
            "answer": "D",
            "reason": "Dependency Injection (DI) involves injecting dependencies at runtime, promoting loose coupling."
        },
        {
            "question": "Which component assembly model allows components to publish and consume services dynamically?",
            "choices": ["A. Factory Pattern", "B. Singleton Pattern", "C. Whiteboard Component Model", "D. Service Locator"],
            "answer": "C",
            "reason": "The Whiteboard Component Model allows components to dynamically publish and consume services at runtime."
        },
        {
            "question": "In the context of component interaction, what is a Required Interface?",
            "choices": ["A. Services a component offers", "B. Services a component needs", "C. Services inherited from a parent component", "D. Services provided by the system runtime"],
            "answer": "B",
            "reason": "A Required Interface defines the services that a component needs from other components."
        },
        {
            "question": "What is the purpose of a Port in component-based design?",
            "choices": ["A. To connect a component to the network", "B. To enable physical deployment", "C. To define interaction points for services", "D. To encapsulate internal methods"],
            "answer": "C",
            "reason": "A Port defines an interaction point through which a component can provide or consume services."
        },
        {
            "question": "What do Delegation Connectors do in component-based design?",
            "choices": ["A. Manage memory allocation", "B. Connect ports to internal classes providing services", "C. Replace the need for interfaces", "D. Enable database replication"],
            "answer": "B",
            "reason": "Delegation Connectors connect ports to the internal classes that provide the services exposed through the port."
        },
        {
            "question": "Which is a key difference between Build-time and Run-time component dependencies?",
            "choices": ["A. Build-time dependencies are resolved dynamically", "B. Run-time dependencies can be assembled dynamically", "C. Run-time dependencies require recompilation", "D. Build-time dependencies are only used for testing"],
            "answer": "B",
            "reason": "Run-time dependencies can be dynamically assembled, allowing greater flexibility compared to build-time dependencies."
        },
        {
            "question": "In the POS case study, replacing BillBiz & BillUI demonstrated what key advantage of component-based architecture?",
            "choices": ["A. Improved database security", "B. Enhanced UI responsiveness", "C. Ability to replace components without redeploying the full app", "D. Reduced memory usage"],
            "answer": "C",
            "reason": "Replacing BillBiz & BillUI without redeploying the full app demonstrates the flexibility and modularity of component-based architecture."
        },
        {
            "question": "Which type of coupling makes a system harder to maintain and test?",
            "choices": ["A. Loose coupling", "B. Tight coupling", "C. No coupling", "D. Dynamic coupling"],
            "answer": "B",
            "reason": "Tight coupling makes a system harder to maintain and test because components depend heavily on each other's internal details."
        },
        {
            "question": "Loose coupling can be achieved by depending on which element?",
            "choices": ["A. Concrete classes", "B. Static methods", "C. Interfaces", "D. Inheritance hierarchies"],
            "answer": "C",
            "reason": "Loose coupling is achieved when components depend on interfaces rather than concrete implementations."
        },
        {
            "question": "Which architecture allows components to be replaced independently?",
            "choices": ["A. Layered Architecture", "B. Monolithic Architecture", "C. Layered Component-Based Architecture", "D. Client-Server Architecture"],
            "answer": "C",
            "reason": "Layered Component-Based Architecture maps layers to physical components, allowing components to be replaced independently."
        },
        {
            "question": "In traditional Layered Architecture, what is a common deployment limitation?",
            "choices": ["A. Components cannot be reused", "B. The entire application often needs redeployment if one layer changes", "C. No support for service orientation", "D. No use of interfaces"],
            "answer": "B",
            "reason": "In traditional Layered Architecture, layers are logical and often tightly packaged, requiring full redeployment when one layer changes."
        },
        {
            "question": "Build-time component dependencies are resolved:",
            "choices": ["A. Dynamically at runtime", "B. During application deployment", "C. During source code compilation", "D. After the application is running"],
            "answer": "C",
            "reason": "Build-time dependencies are resolved during source code compilation."
        },
        {
            "question": "Run-time component dependencies allow:",
            "choices": ["A. More rigid component interactions", "B. More flexible and dynamic component assembly", "C. Tighter integration between layers", "D. Compile-time dependency resolution"],
            "answer": "B",
            "reason": "Run-time dependencies allow for flexible and dynamic component assembly, improving adaptability."
        },
        {
            "question": "Which component assembly model involves a central registry used for looking up services?",
            "choices": ["A. Whiteboard Model", "B. Dependency Injection", "C. Service Locator", "D. Factory Pattern"],
            "answer": "C",
            "reason": "The Service Locator pattern uses a central registry to look up and retrieve required services."
        },
        {
            "question": "Which component assembly model allows components to publish and consume services dynamically at runtime?",
            "choices": ["A. Singleton", "B. Dependency Injection", "C. Factory", "D. Whiteboard Component Model"],
            "answer": "D",
            "reason": "The Whiteboard Component Model enables dynamic service publication and consumption at runtime."
        },
        {
            "question": "Dependency Injection primarily provides what benefit?",
            "choices": ["A. Dynamic service registration", "B. Compile-time wiring of dependencies to promote loose coupling", "C. Static dependency resolution", "D. Hard-coded dependency paths"],
            "answer": "B",
            "reason": "Dependency Injection provides compile-time wiring of dependencies, promoting loose coupling and easier testing."
        },
        {
            "question": "Which interface defines services a component requires from others?",
            "choices": ["A. Provided Interface", "B. Implemented Interface", "C. Required Interface", "D. Composite Interface"],
            "answer": "C",
            "reason": "A Required Interface defines the services that a component needs from other components."
        }
    ],
    "Lecture4: JPMS & Service Locator Pattern": [
        {
            "question": "Which principle suggests that each component should have only one responsibility?",
            "choices": ["A. Open-Closed Principle", "B. Interface Segregation Principle", "C. Single Responsibility Principle", "D. Dependency Inversion Principle"],
            "answer": "C",
            "reason": "The Single Responsibility Principle (SRP) suggests that each component should have only one responsibility."
        },
        {
            "question": "What is the primary purpose of the Service Locator Pattern?",
            "choices": ["A. To manage database connections", "B. To create singletons", "C. To return service instances on demand", "D. To log application activity"],
            "answer": "C",
            "reason": "The Service Locator Pattern is used to return service instances on demand, providing centralized access to services."
        },
        {
            "question": "Which Java utility allows dynamic service discovery at runtime and is part of the SPI mechanism?",
            "choices": ["A. Reflection API", "B. ServiceLoader", "C. Singleton", "D. DI Framework"],
            "answer": "B",
            "reason": "ServiceLoader is a built-in utility in Java that allows dynamic service discovery at runtime and is part of the SPI mechanism."
        },
        {
            "question": "Where are service implementations registered when using SPI?",
            "choices": ["A. META-INF/resources", "B. META-INF/config", "C. META-INF/services", "D. META-INF/classes"],
            "answer": "C",
            "reason": "Service implementations are registered in the META-INF/services directory when using SPI."
        },
        {
            "question": "Which is a limitation of ServiceLoader?",
            "choices": ["A. Supports AOP out of the box", "B. Allows constructor injection", "C. No prioritization or lifecycle management", "D. Supports external source loading"],
            "answer": "C",
            "reason": "ServiceLoader has limitations including no prioritization of services, no lifecycle management, and limited support for complex dependency injection."
        },
        {
            "question": "What is the primary purpose of the Java Platform Module System (JPMS)?",
            "choices": ["A. Provide a new garbage collector", "B. Replace reflection with annotations", "C. Provide modularization of Java applications", "D. Eliminate the need for ServiceLoader"],
            "answer": "C",
            "reason": "JPMS provides modularization of Java applications and the JDK itself, solving various dependency and packaging issues."
        },
        {
            "question": "Which keyword in module-info.java is used to declare required modules?",
            "choices": ["A. provides", "B. uses", "C. requires", "D. exports"],
            "answer": "C",
            "reason": "The requires keyword in module-info.java declares required modules."
        },
        {
            "question": "Which JPMS keyword allows runtime reflection on a package?",
            "choices": ["A. uses", "B. requires", "C. provides", "D. opens"],
            "answer": "D",
            "reason": "The opens keyword allows runtime reflection on a package, which is used by some frameworks."
        },
        {
            "question": "Which problem is NOT addressed by JPMS?",
            "choices": ["A. Classpath Hell", "B. Lack of encapsulation", "C. Large monolithic JDK", "D. Network latency issues"],
            "answer": "D",
            "reason": "JPMS addresses Classpath Hell, lack of encapsulation, and large JDK issues, but it does not address network latency."
        },
        {
            "question": "How does a Module differ from a Component?",
            "choices": ["A. Module focuses on UI design", "B. Component manages code dependencies", "C. Module handles code organization and dependencies, Component focuses on behavior and functionality", "D. They are always the same"],
            "answer": "C",
            "reason": "A Module handles code organization and dependencies, while a Component focuses on behavior and functionality (e.g. UI, business logic)."
        },
        {
            "question": "What JPMS benefit directly addresses the problem of 'Classpath Hell'?",
            "choices": ["A. Smaller runtime", "B. Enhanced reflection", "C. Strong encapsulation", "D. Better dependency management"],
            "answer": "D",
            "reason": "JPMS provides better dependency management, which helps solve the issue of 'Classpath Hell' by making dependencies explicit and modular."
        },
        {
            "question": "What JPMS feature allows the creation of smaller custom Java runtimes?",
            "choices": ["A. module-info.java", "B. jlink", "C. jmod", "D. jpackage"],
            "answer": "B",
            "reason": "jlink allows the creation of smaller, custom Java runtimes using JPMS modules."
        },
        {
            "question": "Which ServiceLoader limitation can cause an application to silently fail to load a service?",
            "choices": ["A. No exception if service missing", "B. No lifecycle management", "C. No constructor injection", "D. No support for AOP"],
            "answer": "A",
            "reason": "ServiceLoader returns an empty iterator if a service is missing, without throwing an exception — this can cause silent failures."
        },
        {
            "question": "ServiceLoader is best suited for which kind of architecture?",
            "choices": ["A. Monolithic apps", "B. Real-time embedded systems", "C. Plugin-based architectures", "D. Microservices"],
            "answer": "C",
            "reason": "ServiceLoader is ideal for plugin-based architectures where dynamic service discovery is needed."
        },
        {
            "question": "Which mechanism supports automatic dependency injection and lifecycle management?",
            "choices": ["A. ServiceLoader", "B. Service Locator", "C. DI frameworks (e.g. Spring)", "D. META-INF/services"],
            "answer": "C",
            "reason": "DI frameworks such as Spring provide automatic dependency injection and lifecycle management."
        },
        {
            "question": "What is the key difference between Service Locator and Dependency Injection?",
            "choices": ["A. Service Locator supports AOP", "B. Dependency Injection is pull-based, Service Locator is push-based", "C. Service Locator requires manual lookup, DI provides automatic injection", "D. There is no difference"],
            "answer": "C",
            "reason": "Service Locator requires manual lookup of services, while Dependency Injection automatically injects dependencies into components."
        },
        {
            "question": "What is a key difference between Module and Component in Java architecture?",
            "choices": ["A. Modules handle UI logic", "B. Components manage memory", "C. Modules manage code organization and dependencies, Components focus on functionality", "D. Modules and Components are the same thing in Java"],
            "answer": "C",
            "reason": "Modules manage code organization and dependencies, while Components focus on behavior and functionality such as UI or business logic."
        },
        {
            "question": "Which problem did JPMS help solve compared to the traditional Java classpath?",
            "choices": ["A. Database connection pooling", "B. Global transaction management", "C. Lack of compile-time dependency verification", "D. UI theming"],
            "answer": "C",
            "reason": "JPMS helps solve the problem of lack of compile-time dependency verification, which was a weakness of the traditional Java classpath."
        },
        {
            "question": "Which JPMS keyword declares a service dependency in module-info.java?",
            "choices": ["A. provides", "B. exports", "C. requires", "D. uses"],
            "answer": "D",
            "reason": "The uses keyword declares a service dependency in module-info.java."
        },
        {
            "question": "Which is a PRO of using ServiceLoader?",
            "choices": ["A. No lifecycle management", "B. Built-in to Java, no third-party framework required", "C. Full support for constructor injection", "D. Guarantees service order"],
            "answer": "B",
            "reason": "A key advantage of ServiceLoader is that it is built-in to Java and does not require any third-party framework to use."
        },
        {
            "question": "Which mechanism provides automatic injection of dependencies?",
            "choices": ["A. ServiceLocator", "B. ServiceLoader", "C. Dependency Injection (DI)", "D. Manual Constructor Calls"],
            "answer": "C",
            "reason": "Dependency Injection (DI) automatically injects dependencies, typically managed by a framework like Spring."
        },
        {
            "question": "Which mechanism requires manual service lookup in a central registry?",
            "choices": ["A. ServiceLoader", "B. Dependency Injection", "C. Service Locator", "D. Reflection"],
            "answer": "C",
            "reason": "The Service Locator pattern requires components to manually look up services from a central registry."
        },
        {
            "question": "Which mechanism uses the META-INF/services directory for service registration?",
            "choices": ["A. Service Locator", "B. ServiceLoader", "C. Dependency Injection", "D. Reflection API"],
            "answer": "B",
            "reason": "ServiceLoader uses the META-INF/services directory to register service implementations."
        },
        {
            "question": "Which mechanism is most suitable for plugin-based architectures?",
            "choices": ["A. Dependency Injection", "B. ServiceLocator", "C. Factory Pattern", "D. ServiceLoader"],
            "answer": "D",
            "reason": "ServiceLoader is ideal for plugin-based architectures that require dynamic service discovery."
        },
        {
            "question": "In Java architecture, which is the focus of a Module?",
            "choices": ["A. Defining business functionality", "B. Managing code organization and dependencies", "C. Implementing UI design", "D. Managing user sessions"],
            "answer": "B",
            "reason": "A Module focuses on managing code organization and dependencies in a Java system."
        },
        {
            "question": "In Java architecture, which is the focus of a Component?",
            "choices": ["A. Code packaging and distribution", "B. Handling JVM memory", "C. Defining behavior and functionality such as UI or business logic", "D. Managing modules"],
            "answer": "C",
            "reason": "A Component focuses on behavior and functionality — such as UI elements, business logic, or services."
        },
        {
            "question": "Which problem did JPMS directly address compared to the traditional Java classpath?",
            "choices": ["A. Lack of thread management", "B. No compile-time dependency verification", "C. No support for web apps", "D. Limited garbage collection"],
            "answer": "B",
            "reason": "JPMS introduced compile-time dependency verification, which the traditional classpath lacked."
        },
        {
            "question": "Which of the following was a problem before JPMS?",
            "choices": ["A. Strong encapsulation", "B. Classpath Hell", "C. Compile-time dependency checks", "D. Smaller custom runtimes"],
            "answer": "B",
            "reason": "Classpath Hell — where conflicting classes on the classpath caused runtime errors — was a major problem before JPMS."
        },
        {
            "question": "Which is a limitation of ServiceLoader?",
            "choices": ["A. Built-in Java support", "B. Easy service prioritization", "C. No lifecycle management", "D. Full support for dependency injection"],
            "answer": "C",
            "reason": "ServiceLoader has limitations such as no lifecycle management or prioritization of loaded services."
        },
        {
            "question": "Which is a key benefit of using JPMS?",
            "choices": ["A. Makes all public classes globally accessible", "B. Increases the size of the Java runtime", "C. Strong encapsulation of modules", "D. Requires external tools to manage modules"],
            "answer": "C",
            "reason": "One of the main benefits of JPMS is strong encapsulation — only explicitly exported packages are visible to other modules."
        }
    ],
    "Lecture5: Dependency Injection & Component Frameworks": [
        {
            "question": "Which type of component framework is designed to be reusable across different domains?",
            "choices": ["A. Vertical Component Framework", "B. Horizontal Component Framework", "C. Domain-specific Framework", "D. Legacy Framework"],
            "answer": "B",
            "reason": "A Horizontal Component Framework is designed to be reusable across different domains and is loosely coupled."
        },
        {
            "question": "Which type of component composition requires recompilation and redeployment when changes are made?",
            "choices": ["A. Dynamic Component Composition", "B. Runtime Composition", "C. Static Component Composition", "D. Loose Composition"],
            "answer": "C",
            "reason": "Static Component Composition is integrated at compile-time/build-time and requires recompilation and redeployment when changes occur."
        },
        {
            "question": "In which type of component composition is the internal logic completely hidden?",
            "choices": ["A. White-box Composition", "B. Black-box Composition", "C. Gray-box Composition", "D. Hybrid Composition"],
            "answer": "B",
            "reason": "In Black-box Composition, the internal logic is completely hidden and interaction happens through well-defined interfaces."
        },
        {
            "question": "Which type of Java component model defines lifecycle management and component communication mechanisms?",
            "choices": ["A. Factory Pattern", "B. Component Model", "C. Singleton Pattern", "D. MVC Model"],
            "answer": "B",
            "reason": "A Component Model defines lifecycle management, communication mechanisms, and composition rules for components."
        },
        {
            "question": "Which EJB type is used for asynchronous processing?",
            "choices": ["A. Stateless Session Bean", "B. Stateful Session Bean", "C. Message-Driven Bean", "D. Entity Bean"],
            "answer": "C",
            "reason": "Message-Driven Beans are used for asynchronous processing in the EJB architecture."
        },
        {
            "question": "Which is a major problem with traditional EJBs in the context of modern microservices architecture?",
            "choices": ["A. Too lightweight", "B. Requires no server", "C. Heavyweight and requires a full EE-compliant server", "D. Cannot use transactions"],
            "answer": "C",
            "reason": "Traditional EJBs are heavyweight and require a full EE-compliant server, making them unsuitable for modern lightweight microservices."
        },
        {
            "question": "What does Inversion of Control (IoC) primarily promote?",
            "choices": ["A. Tight coupling", "B. Loose coupling and modularity", "C. Direct control by the main program", "D. Strong inheritance hierarchies"],
            "answer": "B",
            "reason": "IoC promotes loose coupling and modularity by letting the framework control the program flow."
        },
        {
            "question": "Which type of Dependency Injection is best suited for mandatory dependencies?",
            "choices": ["A. Interface Injection", "B. Setter Injection", "C. Constructor Injection", "D. Field Injection"],
            "answer": "C",
            "reason": "Constructor Injection is best for mandatory dependencies, ensuring they are provided when the object is created."
        },
        {
            "question": "Which type of Dependency Injection is best used for optional dependencies?",
            "choices": ["A. Constructor Injection", "B. Setter Injection", "C. Field Injection", "D. Reflection Injection"],
            "answer": "B",
            "reason": "Setter Injection is typically used for optional dependencies, allowing them to be set after object construction."
        },
        {
            "question": "What is the main purpose of the Decorator Design Pattern?",
            "choices": ["A. Replace inheritance", "B. Add responsibilities to objects at runtime", "C. Simplify code generation", "D. Eliminate object dependencies"],
            "answer": "B",
            "reason": "The Decorator Design Pattern adds responsibilities to objects at runtime, promoting flexibility through composition."
        },
        {
            "question": "Which of the following violates the Liskov Substitution Principle (LSP)?",
            "choices": ["A. Subclass uses same method signatures as superclass", "B. Subclass weakens postconditions", "C. Subclass is interchangeable with superclass", "D. Subclass preserves behavioral consistency"],
            "answer": "B",
            "reason": "Weakening postconditions in a subclass violates the Liskov Substitution Principle, which requires behavioral consistency."
        },
        {
            "question": "Which type of Dependency Injection is least commonly used and typically framework-specific?",
            "choices": ["A. Constructor Injection", "B. Setter Injection", "C. Interface Injection", "D. Field Injection"],
            "answer": "C",
            "reason": "Interface Injection is less commonly used and is typically found in specific frameworks rather than general practice."
        },
        {
            "question": "Which framework is considered a modern lightweight alternative to EJB?",
            "choices": ["A. CORBA", "B. Spring Framework", "C. Java EE", "D. COM"],
            "answer": "B",
            "reason": "Spring Framework is a modern lightweight component model and Dependency Injection framework that offers an alternative to the heavier EJB model."
        },
        {
            "question": "Which term describes a framework controlling the program flow instead of the developer writing main flow logic?",
            "choices": ["A. Factory Pattern", "B. Inversion of Control (IoC)", "C. Singleton Pattern", "D. Prototype Pattern"],
            "answer": "B",
            "reason": "Inversion of Control (IoC) describes the principle where a framework controls the program flow instead of the developer writing main flow logic."
        },
        {
            "question": "Which type of component composition allows components to be loaded or changed at runtime?",
            "choices": ["A. Static Component Composition", "B. Dynamic Component Composition", "C. Black-box Composition", "D. Tight Component Composition"],
            "answer": "B",
            "reason": "Dynamic Component Composition allows components to be loaded or changed at runtime, improving adaptability."
        },
        {
            "question": "In which type of composition is the internal logic both visible and modifiable?",
            "choices": ["A. Black-box Composition", "B. Gray-box Composition", "C. White-box Composition", "D. Static Composition"],
            "answer": "C",
            "reason": "White-box Composition exposes and allows modification of the internal logic of the component."
        },
        {
            "question": "Which type of component composition is a mix of Black-box and White-box, exposing some metadata or extensions?",
            "choices": ["A. Static Composition", "B. Dynamic Composition", "C. Gray-box Composition", "D. White-box Composition"],
            "answer": "C",
            "reason": "Gray-box Composition is a mix of Black-box and White-box, exposing some metadata or extension points for flexibility."
        },
        {
            "question": "What is a key difference between EJB and Spring Framework?",
            "choices": ["A. EJB is lightweight; Spring is heavyweight", "B. Spring supports DI and is lightweight; EJB requires full EE container", "C. Both require EE container", "D. EJB supports AOP natively, Spring does not"],
            "answer": "B",
            "reason": "Spring Framework supports DI and is lightweight, whereas EJB requires a full EE-compliant container and is heavier."
        },
        {
            "question": "What is the relationship between IoC and DI?",
            "choices": ["A. DI is an implementation of IoC", "B. IoC is a type of DI", "C. They are unrelated", "D. DI replaces IoC"],
            "answer": "A",
            "reason": "Dependency Injection (DI) is a specific implementation of the Inversion of Control (IoC) principle."
        },
        {
            "question": "Which type of injection is best when dependency values must always be provided during object creation?",
            "choices": ["A. Interface Injection", "B. Setter Injection", "C. Constructor Injection", "D. Field Injection"],
            "answer": "C",
            "reason": "Constructor Injection is used when dependency values must always be provided during object creation."
        },
        {
            "question": "Which type of component composition allows components to be changed at runtime without redeploying the application?",
            "choices": ["A. Static Component Composition", "B. Dynamic Component Composition", "C. Black-box Composition", "D. Tight Component Composition"],
            "answer": "B",
            "reason": "Dynamic Component Composition allows components to be changed at runtime, making the system more adaptable."
        },
        {
            "question": "Which type of component composition requires recompilation and redeployment when components change?",
            "choices": ["A. Black-box Composition", "B. Gray-box Composition", "C. Static Component Composition", "D. Dynamic Component Composition"],
            "answer": "C",
            "reason": "Static Component Composition integrates components at build-time, requiring recompilation and redeployment when changes occur."
        },
        {
            "question": "In which type of composition is the internal logic of components completely hidden?",
            "choices": ["A. White-box Composition", "B. Black-box Composition", "C. Gray-box Composition", "D. Hybrid Composition"],
            "answer": "B",
            "reason": "In Black-box Composition, the internal logic is completely hidden, and components interact via defined interfaces."
        },
        {
            "question": "Which type of composition allows partial visibility and extensibility via metadata or extensions?",
            "choices": ["A. Black-box Composition", "B. Gray-box Composition", "C. White-box Composition", "D. Dynamic Composition"],
            "answer": "B",
            "reason": "Gray-box Composition allows partial visibility through metadata or extensions, combining aspects of Black-box and White-box composition."
        },
        {
            "question": "Which framework is considered lightweight and supports Dependency Injection out of the box?",
            "choices": ["A. EJB", "B. Spring Framework", "C. Java EE", "D. CORBA"],
            "answer": "B",
            "reason": "Spring Framework is lightweight and provides built-in support for Dependency Injection (DI)."
        },
        {
            "question": "Which component model requires a full Java EE-compliant server and is considered heavyweight?",
            "choices": ["A. Spring Framework", "B. MicroProfile", "C. EJB", "D. OSGi"],
            "answer": "C",
            "reason": "EJB (Enterprise JavaBeans) requires a full EE-compliant server and is considered heavyweight compared to Spring Framework."
        },
        {
            "question": "Which term refers to the design principle where a framework controls the program flow instead of the developer?",
            "choices": ["A. Dependency Injection", "B. Inversion of Control", "C. Liskov Substitution Principle", "D. Singleton Pattern"],
            "answer": "B",
            "reason": "Inversion of Control (IoC) is the design principle where a framework, not the developer, controls the program flow."
        },
        {
            "question": "What is the relationship between IoC and Dependency Injection?",
            "choices": ["A. IoC is implemented through Dependency Injection", "B. DI is implemented through IoC", "C. They are unrelated", "D. DI replaces IoC entirely"],
            "answer": "A",
            "reason": "IoC is implemented through Dependency Injection; DI is one way to achieve Inversion of Control."
        },
        {
            "question": "Violating the Liskov Substitution Principle typically results in:",
            "choices": ["A. Better modularity", "B. Stronger encapsulation", "C. Unexpected behavior when substituting subclasses", "D. Better inheritance hierarchies"],
            "answer": "C",
            "reason": "Violating LSP leads to unexpected behavior when substituting subclasses in place of their superclasses."
        },
        {
            "question": "Which type of Dependency Injection is most suitable for providing mandatory dependencies at object creation?",
            "choices": ["A. Setter Injection", "B. Interface Injection", "C. Constructor Injection", "D. Field Injection"],
            "answer": "C",
            "reason": "Constructor Injection is most suitable for providing mandatory dependencies during object creation, ensuring they are always available."
        }
    ],
    "Lecture6: Spring Framework & Aspect-Oriented Programming (AOP)": [
        {
            "question": "Which core feature of the Spring Framework is responsible for managing the lifecycle and configuration of components?",
            "choices": ["A. MVC", "B. IoC Container", "C. AOP", "D. Spring Boot Starter"],
            "answer": "B",
            "reason": "The IoC (Inversion of Control) Container is responsible for managing the lifecycle and configuration of components in the Spring Framework."
        },
        {
            "question": "In Spring, what is an object that is managed by the Spring IoC container called?",
            "choices": ["A. Bean", "B. Controller", "C. Aspect", "D. Module"],
            "answer": "A",
            "reason": "An object that is managed by the Spring IoC container is called a Bean."
        },
        {
            "question": "Which Spring Bean scope creates one instance per HTTP request?",
            "choices": ["A. Singleton", "B. Prototype", "C. Request", "D. Session"],
            "answer": "C",
            "reason": "The Request scope creates a new bean instance for each HTTP request."
        },
        {
            "question": "Which Spring container is considered more advanced and supports AOP, i18n, and events?",
            "choices": ["A. BeanFactory", "B. AnnotationConfigApplicationContext", "C. WebApplicationContext", "D. ApplicationContext"],
            "answer": "D",
            "reason": "ApplicationContext is the more advanced Spring container that supports AOP, internationalization (i18n), and events."
        },
        {
            "question": "Which annotation is used to define a configuration class in Spring?",
            "choices": ["A. @Component", "B. @Bean", "C. @Configuration", "D. @Service"],
            "answer": "C",
            "reason": "The @Configuration annotation is used to define a configuration class in Spring."
        },
        {
            "question": "Which stereotype annotation is used for data access components?",
            "choices": ["A. @Component", "B. @Controller", "C. @Service", "D. @Repository"],
            "answer": "D",
            "reason": "The @Repository annotation is used to indicate a DAO or database access component."
        },
        {
            "question": "In AOP, which term describes an action performed at a particular join point?",
            "choices": ["A. Aspect", "B. Advice", "C. Pointcut", "D. Weaving"],
            "answer": "B",
            "reason": "Advice is the action performed at a particular join point in AOP."
        },
        {
            "question": "Which term in AOP refers to a specific execution point, such as a method call or exception?",
            "choices": ["A. Aspect", "B. Advice", "C. Join Point", "D. Weaving"],
            "answer": "C",
            "reason": "A Join Point is a specific point in the program execution, such as a method call or exception, where an aspect can be applied."
        },
        {
            "question": "Which is a key advantage of using AOP?",
            "choices": ["A. Increases boilerplate code", "B. Reduces testability", "C. Improves modularity by centralizing cross-cutting concerns", "D. Prevents bean lifecycle management"],
            "answer": "C",
            "reason": "AOP improves modularity by centralizing cross-cutting concerns such as logging, security, and transaction management."
        },
        {
            "question": "Which Spring Boot feature simplifies dependency and configuration management?",
            "choices": ["A. AspectJ", "B. Spring Boot Starter", "C. WebApplicationContext", "D. BeanFactory"],
            "answer": "B",
            "reason": "Spring Boot Starters simplify dependency and configuration management by providing pre-configured sets of dependencies."
        },
        {
            "question": "In AOP, which element defines a reusable expression for selecting join points?",
            "choices": ["A. Advice", "B. Aspect", "C. Pointcut", "D. Weaving"],
            "answer": "C",
            "reason": "A Pointcut defines a reusable expression that matches join points where Advice should be applied."
        },
        {
            "question": "What is the process of applying aspects to a target object called?",
            "choices": ["A. Aspecting", "B. Advising", "C. Weaving", "D. Injecting"],
            "answer": "C",
            "reason": "Weaving is the process of applying aspects to a target object, either at compile time, load time, or runtime."
        },
        {
            "question": "Which AOP concept encapsulates a cross-cutting concern?",
            "choices": ["A. Join Point", "B. Advice", "C. Pointcut", "D. Aspect"],
            "answer": "D",
            "reason": "An Aspect encapsulates a cross-cutting concern such as logging, security, or transaction management."
        },
        {
            "question": "Which ApplicationContext implementation is recommended for modern Spring apps using Java-based configuration?",
            "choices": ["A. ClassPathXmlApplicationContext", "B. FileSystemXmlApplicationContext", "C. AnnotationConfigApplicationContext", "D. WebApplicationContext"],
            "answer": "C",
            "reason": "AnnotationConfigApplicationContext is recommended for modern Spring apps using Java-based configuration and annotations."
        },
        {
            "question": "Which bean scope is the default in Spring?",
            "choices": ["A. Singleton", "B. Prototype", "C. Request", "D. Session"],
            "answer": "A",
            "reason": "Singleton is the default scope in Spring, meaning only one instance of the bean is created in the container."
        },
        {
            "question": "Which configuration style is more modern and preferred in new Spring apps?",
            "choices": ["A. XML-based configuration", "B. Java Annotation-based configuration", "C. Properties file configuration", "D. Manual wiring"],
            "answer": "B",
            "reason": "Java Annotation-based configuration is preferred in modern Spring applications for its simplicity and readability."
        },
        {
            "question": "What is a key difference between BeanFactory and ApplicationContext?",
            "choices": ["A. ApplicationContext only supports XML", "B. BeanFactory supports AOP", "C. ApplicationContext supports advanced features like AOP and events", "D. BeanFactory supports Web MVC"],
            "answer": "C",
            "reason": "ApplicationContext supports advanced features like AOP, i18n, events, and Web contexts, while BeanFactory does not."
        },
        {
            "question": "How does AOP differ from traditional code coupling?",
            "choices": ["A. AOP increases boilerplate code", "B. AOP tightly couples cross-cutting concerns with business logic", "C. AOP centralizes cross-cutting concerns, improving modularity", "D. AOP eliminates the need for DI"],
            "answer": "C",
            "reason": "AOP centralizes cross-cutting concerns, such as logging or security, improving modularity and maintainability."
        },
        {
            "question": "What is a key difference between AspectJ and Spring AOP?",
            "choices": ["A. Spring AOP supports compile-time weaving", "B. AspectJ is fully integrated with Spring Boot", "C. AspectJ is more powerful and supports compile-time weaving, while Spring AOP is simpler and limited to method execution join points", "D. They are identical"],
            "answer": "C",
            "reason": "AspectJ is more powerful and supports compile-time weaving and various join points, while Spring AOP is simpler and limited to method execution join points."
        },
        {
            "question": "What is a key benefit of using Spring Boot over standard Spring Framework?",
            "choices": ["A. Requires complex XML configuration", "B. Forces use of AspectJ", "C. Simplifies app development with auto-configuration and embedded servers", "D. Only works with JDBC"],
            "answer": "C",
            "reason": "Spring Boot simplifies app development by providing auto-configuration, embedded servers, and Spring Boot Starters for rapid setup."
        },
        {
            "question": "Which Spring container supports advanced features like AOP, events, and internationalization?",
            "choices": ["A. BeanFactory", "B. ApplicationContext", "C. BeanPostProcessor", "D. BeanDefinitionRegistry"],
            "answer": "B",
            "reason": "ApplicationContext supports advanced features such as AOP, events, and internationalization (i18n), whereas BeanFactory is more basic."
        },
        {
            "question": "Which Spring configuration style is generally preferred in modern applications?",
            "choices": ["A. XML-based configuration", "B. Manual Java code wiring", "C. Java Annotation-based configuration", "D. WebApplicationContext-only configuration"],
            "answer": "C",
            "reason": "Java Annotation-based configuration is preferred in modern Spring applications because it simplifies configuration and reduces boilerplate."
        },
        {
            "question": "Which Spring Bean scope ensures that only one instance of a bean exists in the container?",
            "choices": ["A. Prototype", "B. Request", "C. Session", "D. Singleton"],
            "answer": "D",
            "reason": "Singleton is the default Spring Bean scope, ensuring that only one instance of the bean exists in the container."
        },
        {
            "question": "Which Spring Bean scope creates a new instance of a bean each time it is requested?",
            "choices": ["A. Singleton", "B. Prototype", "C. Request", "D. Session"],
            "answer": "B",
            "reason": "Prototype scope creates a new instance of a bean each time it is requested from the Spring container."
        },
        {
            "question": "How does Inversion of Control (IoC) differ from Dependency Injection (DI)?",
            "choices": ["A. IoC is an implementation of DI", "B. DI is an implementation of IoC", "C. They are unrelated", "D. DI replaces IoC completely"],
            "answer": "B",
            "reason": "Dependency Injection (DI) is a specific implementation of the broader Inversion of Control (IoC) principle."
        },
        {
            "question": "Which of the following is a benefit of using AOP compared to traditional code coupling?",
            "choices": ["A. Tightly couples cross-cutting concerns with business logic", "B. Centralizes cross-cutting concerns to improve modularity", "C. Eliminates the need for DI", "D. Increases code duplication"],
            "answer": "B",
            "reason": "AOP centralizes cross-cutting concerns (like logging, security), improving modularity and simplifying business logic."
        },
        {
            "question": "Which AOP tool offers more advanced capabilities and supports compile-time weaving?",
            "choices": ["A. Spring AOP", "B. BeanFactory", "C. AspectJ", "D. WebApplicationContext"],
            "answer": "C",
            "reason": "AspectJ is more powerful than Spring AOP and supports compile-time weaving and a broader range of join points."
        },
        {
            "question": "Which AOP tool is simpler and integrated directly with the Spring Framework?",
            "choices": ["A. AspectJ", "B. Java EE", "C. Spring AOP", "D. JBoss AOP"],
            "answer": "C",
            "reason": "Spring AOP is simpler than AspectJ and is directly integrated with the Spring Framework, suitable for common AOP use cases."
        },
        {
            "question": "What is a key advantage of using Spring Boot compared to standard Spring Framework?",
            "choices": ["A. Requires more configuration", "B. Forces XML-based configuration", "C. Provides auto-configuration and embedded servers for rapid development", "D. Only works with Spring MVC"],
            "answer": "C",
            "reason": "Spring Boot provides auto-configuration, embedded servers, and Spring Boot Starters for rapid application development."
        },
        {
            "question": "How does standard Spring Framework differ from Spring Boot?",
            "choices": ["A. Spring Boot requires XML config", "B. Spring Framework has auto-configuration", "C. Spring Boot simplifies setup with auto-configuration and embedded servers", "D. They are identical"],
            "answer": "C",
            "reason": "Spring Boot simplifies application setup with auto-configuration and embedded servers, while standard Spring Framework requires more manual configuration."
        }
    ],
    "Lecture7: Communication Protocols & Software Architecture Patterns": [
        {
            "question": "Which architectural style is REST based on?",
            "choices": ["A. FTP", "B. SMTP", "C. HTTP", "D. SOAP"],
            "answer": "C",
            "reason": "REST (Representational State Transfer) is based on HTTP and the standard CRUD operations (GET, POST, PUT, DELETE)."
        },
        {
            "question": "Which REST principle ensures that each request contains all necessary information for processing?",
            "choices": ["A. Client-Server", "B. Statelessness", "C. Cacheability", "D. Code on Demand"],
            "answer": "B",
            "reason": "The Statelessness principle ensures that each request in REST contains all the necessary information, and the server does not store client state between requests."
        },
        {
            "question": "What is the main function of OpenAPI?",
            "choices": ["A. Secure APIs", "B. Handle transactions", "C. Document and design REST APIs", "D. Encrypt data"],
            "answer": "C",
            "reason": "OpenAPI (formerly Swagger) is a specification used to document and design REST APIs, providing interactive tools and automation."
        },
        {
            "question": "What does SOAP stand for?",
            "choices": ["A. Simple Online Access Protocol", "B. Secure Object Access Protocol", "C. Simple Object Access Protocol", "D. Standard Object Application Protocol"],
            "answer": "C",
            "reason": "SOAP stands for Simple Object Access Protocol, used for exchanging structured information in web services."
        },
        {
            "question": "In WSDL, which element defines the service interface?",
            "choices": ["A. <definitions>", "B. <types>", "C. <portType>", "D. <binding>"],
            "answer": "C",
            "reason": "<portType> defines the set of operations (service interface) in a WSDL document."
        },
        {
            "question": "Which messaging model ensures one message is consumed by only one consumer?",
            "choices": ["A. Publish-Subscribe", "B. Message Streams", "C. Point-to-Point", "D. Fanout"],
            "answer": "C",
            "reason": "Point-to-Point messaging ensures that one message is consumed by only one consumer, typically via a queue."
        },
        {
            "question": "Which RabbitMQ feature supports communication where one message can reach multiple subscribers?",
            "choices": ["A. Point-to-Point", "B. RPC", "C. Publish-Subscribe", "D. Delayed Queue"],
            "answer": "C",
            "reason": "RabbitMQ supports Publish-Subscribe messaging through fanout exchanges, allowing one message to reach multiple subscribers."
        },
        {
            "question": "What is the primary benefit of using Message-Oriented Middleware (MOM)?",
            "choices": ["A. Tight coupling of systems", "B. High performance but complex integration", "C. Decouples producers and consumers", "D. Forces synchronous communication"],
            "answer": "C",
            "reason": "MOM decouples producers and consumers, enabling asynchronous and flexible communication between distributed systems."
        },
        {
            "question": "Which Software Architecture Pattern is most commonly used for CRUD-heavy applications?",
            "choices": ["A. Event-Driven Architecture", "B. Service-Oriented Architecture", "C. Microservices", "D. Layered Architecture"],
            "answer": "D",
            "reason": "Layered Architecture is commonly used for CRUD-heavy applications due to its simplicity and separation of concerns."
        },
        {
            "question": "Which topology in Event-Driven Architecture uses a central event orchestrator?",
            "choices": ["A. Broker", "B. Queue", "C. Mediator", "D. Stream"],
            "answer": "C",
            "reason": "In the Mediator topology of Event-Driven Architecture, a central event orchestrator coordinates events between producers and consumers."
        },
        {
            "question": "Which is an advantage of REST over SOAP?",
            "choices": ["A. More rigid structure", "B. Statelessness and simplicity", "C. Requires WSDL", "D. Primarily used with XML"],
            "answer": "B",
            "reason": "REST is stateless and simpler to implement compared to SOAP, which has a more rigid structure and typically requires WSDL."
        },
        {
            "question": "Which messaging model supports real-time streaming and message replay?",
            "choices": ["A. Point-to-Point", "B. Message Streams", "C. RPC", "D. Publish-Subscribe"],
            "answer": "B",
            "reason": "Message Streams (such as Apache Kafka) support real-time streaming and message replay through an append-only log."
        },
        {
            "question": "What is a key benefit of using a Broker topology in Event-Driven Architecture?",
            "choices": ["A. Centralized coordination of all events", "B. Maximal decoupling between producers and consumers", "C. Synchronous event handling", "D. Single point of failure"],
            "answer": "B",
            "reason": "The Broker topology in EDA provides maximal decoupling by having producers publish events to a broker that consumers subscribe to."
        },
        {
            "question": "In which EDA topology does a central orchestrator manage the flow of events?",
            "choices": ["A. Point-to-Point", "B. Broker", "C. Mediator", "D. Layered"],
            "answer": "C",
            "reason": "In the Mediator topology, a central orchestrator manages the flow of events between producers and consumers."
        },
        {
            "question": "How do Architecture Patterns differ from Design Patterns?",
            "choices": ["A. Architecture Patterns focus on small class interactions", "B. Architecture Patterns provide high-level structure for systems", "C. Design Patterns focus on major system components", "D. They are the same"],
            "answer": "B",
            "reason": "Architecture Patterns provide high-level structure for entire systems, while Design Patterns address class/object interactions."
        },
        {
            "question": "Which of the following is an example of a Software Architecture Pattern?",
            "choices": ["A. Factory Pattern", "B. Adapter Pattern", "C. Event-Driven Architecture", "D. Decorator Pattern"],
            "answer": "C",
            "reason": "Event-Driven Architecture is an example of a Software Architecture Pattern that structures system components around events."
        },
        {
            "question": "Which is an advantage of Layered Architecture?",
            "choices": ["A. High coupling between layers", "B. Familiarity and ease of development", "C. Single point of failure", "D. Difficult to test"],
            "answer": "B",
            "reason": "An advantage of Layered Architecture is its familiarity to developers and ease of development and maintenance."
        },
        {
            "question": "Which is a disadvantage of Layered Architecture?",
            "choices": ["A. Hard to maintain", "B. Difficult to develop", "C. Low agility and scalability", "D. Incompatible with CRUD-heavy apps"],
            "answer": "C",
            "reason": "A disadvantage of Layered Architecture is low agility and scalability, making it harder to scale or replace parts of the system."
        },
        {
            "question": "Which transport protocols can SOAP use?",
            "choices": ["A. HTTP only", "B. SMTP only", "C. Multiple protocols like HTTP, SMTP, TCP", "D. WebSockets only"],
            "answer": "C",
            "reason": "SOAP is protocol-agnostic and can use multiple transport protocols such as HTTP, SMTP, and TCP."
        },
        {
            "question": "Which type of Web Service is typically faster due to using JSON and simpler structures?",
            "choices": ["A. SOAP", "B. REST", "C. XML-RPC", "D. Streaming Web Services"],
            "answer": "B",
            "reason": "REST is typically faster and lighter because it often uses JSON and avoids the complex, strict structures of SOAP."
        },
        {
            "question": "Which web service type typically uses a strict XML-based protocol?",
            "choices": ["A. REST", "B. SOAP", "C. WebSockets", "D. JSON-RPC"],
            "answer": "B",
            "reason": "SOAP (Simple Object Access Protocol) is XML-based and follows a strict protocol for exchanging structured information."
        },
        {
            "question": "Which web service type is typically faster and more lightweight, often using JSON?",
            "choices": ["A. SOAP", "B. REST", "C. WSDL", "D. WebSockets"],
            "answer": "B",
            "reason": "REST is typically faster and more lightweight because it often uses JSON and avoids the strict structure of SOAP."
        },
        {
            "question": "In MOM, which model ensures that a message is processed by only one consumer?",
            "choices": ["A. Message Streams", "B. Publish-Subscribe", "C. Point-to-Point (Queues)", "D. RPC"],
            "answer": "C",
            "reason": "Point-to-Point messaging (Queues) ensures that a message is processed by only one consumer."
        },
        {
            "question": "In MOM, which model supports real-time streaming and message replay?",
            "choices": ["A. Point-to-Point (Queues)", "B. Publish-Subscribe", "C. Message Streams", "D. RPC"],
            "answer": "C",
            "reason": "Message Streams (such as those in Apache Kafka) support real-time streaming and message replay via an append-only log."
        },
        {
            "question": "In EDA, which topology uses a central event orchestrator to manage events?",
            "choices": ["A. Point-to-Point", "B. Publish-Subscribe", "C. Mediator", "D. Broker"],
            "answer": "C",
            "reason": "The Mediator topology in Event-Driven Architecture uses a central orchestrator to manage events between producers and consumers."
        },
        {
            "question": "In EDA, which topology maximizes decoupling by letting producers publish to a broker and consumers subscribe to events?",
            "choices": ["A. Point-to-Point", "B. Publish-Subscribe", "C. Mediator", "D. Broker"],
            "answer": "D",
            "reason": "The Broker topology maximizes decoupling by letting producers publish events to a broker, and consumers independently subscribe to events."
        },
        {
            "question": "How do Architecture Patterns differ from Design Patterns?",
            "choices": ["A. Architecture Patterns solve OOP class problems", "B. Architecture Patterns provide high-level system structure", "C. Design Patterns define system layers", "D. They are identical"],
            "answer": "B",
            "reason": "Architecture Patterns provide high-level system structure and help organize major components, while Design Patterns solve OOP class and object interaction problems."
        },
        {
            "question": "Which is an example of an Architecture Pattern?",
            "choices": ["A. Adapter Pattern", "B. Layered Architecture", "C. Decorator Pattern", "D. Factory Pattern"],
            "answer": "B",
            "reason": "Layered Architecture is an example of an Architecture Pattern that defines the overall structure of a system."
        },
        {
            "question": "Which is an advantage of Layered Architecture?",
            "choices": ["A. High testability and separation of concerns", "B. Tight coupling between layers", "C. Inflexibility in adding new features", "D. Difficult to maintain"],
            "answer": "A",
            "reason": "An advantage of Layered Architecture is its high testability and separation of concerns, making it easier to develop and maintain."
        },
        {
            "question": "Which is a disadvantage of Layered Architecture?",
            "choices": ["A. Supports only REST", "B. Architecture sinkhole and scalability issues", "C. Requires WebSockets", "D. Cannot be used with MOM"],
            "answer": "B",
            "reason": "Layered Architecture can suffer from architecture sinkholes (layers that do little) and low agility/scalability as disadvantages."
        }
    ],
    "Lecture8: SOA & Introduction to Microservices": [
        {
            "question": "In SOA, which component acts as a central directory to discover services?",
            "choices": ["A. Service Consumer", "B. Service Contract", "C. Service Registry", "D. Message Bus"],
            "answer": "C",
            "reason": "The Service Registry acts as a central directory where services are registered and discovered by service consumers in SOA."
        },
        {
            "question": "What is the role of Service Orchestration in SOA?",
            "choices": ["A. No central controller", "B. Services discover each other dynamically", "C. Central controller coordinates service interaction", "D. Services follow a global interaction protocol"],
            "answer": "C",
            "reason": "Service Orchestration uses a central controller to coordinate and manage interactions between services."
        },
        {
            "question": "Which is a key characteristic of SOA?",
            "choices": ["A. Tight coupling", "B. Single Responsibility Principle", "C. Loose coupling", "D. Monolithic deployment"],
            "answer": "C",
            "reason": "Loose coupling is a key characteristic of SOA, allowing services to be independent and reusable."
        },
        {
            "question": "Which is a major challenge of SOA?",
            "choices": ["A. Lack of scalability", "B. Lack of reusability", "C. Complex service governance", "D. Inability to support multiple languages"],
            "answer": "C",
            "reason": "Complex service governance is a key challenge in SOA, especially when managing numerous services and their interactions."
        },
        {
            "question": "In CBD vs SOA, which architecture typically uses in-process calls for communication?",
            "choices": ["A. SOA", "B. REST", "C. CBD", "D. gRPC"],
            "answer": "C",
            "reason": "Component-Based Development (CBD) typically uses in-process calls for communication between components."
        },
        {
            "question": "In Microservices architecture, what is the best practice regarding databases?",
            "choices": ["A. Shared database across services", "B. No database per service", "C. Database per service", "D. Central database for the whole system"],
            "answer": "C",
            "reason": "Best practice in Microservices is to use Database per Service, which ensures that services remain loosely coupled and independently deployable."
        },
        {
            "question": "What is the purpose of an API Gateway in Microservices?",
            "choices": ["A. Acts as a single-entry point for clients", "B. Stores microservice data", "C. Manages microservice deployment", "D. Handles service orchestration"],
            "answer": "A",
            "reason": "The API Gateway acts as a single-entry point for clients, managing routing, authentication, aggregation, and other cross-cutting concerns."
        },
        {
            "question": "Which pattern allows services to dynamically find each other without hardcoded configurations?",
            "choices": ["A. API Gateway", "B. Service Registry", "C. Bounded Context", "D. Event Bus"],
            "answer": "B",
            "reason": "The Service Discovery pattern uses a Service Registry to enable services to dynamically find each other without hardcoding IPs or hostnames."
        },
        {
            "question": "Which gRPC feature allows efficient parallel requests over a single connection?",
            "choices": ["A. REST", "B. SOAP", "C. HTTP/2 Multiplexing", "D. JSON-RPC"],
            "answer": "C",
            "reason": "HTTP/2 Multiplexing allows gRPC to send multiple parallel requests over a single connection efficiently."
        },
        {
            "question": "Which format does gRPC use for payload serialization?",
            "choices": ["A. JSON", "B. XML", "C. Protobuf", "D. YAML"],
            "answer": "C",
            "reason": "gRPC uses Protocol Buffers (Protobuf), a compact and fast binary serialization format."
        },
        {
            "question": "What is the purpose of the Bounded Context pattern in Microservices architecture?",
            "choices": ["A. To share a single database", "B. To reduce the number of services", "C. To define a clear logical boundary for domain models", "D. To centralize all API calls"],
            "answer": "C",
            "reason": "The Bounded Context pattern defines a clear logical boundary for domain models, helping to align one microservice per bounded context for clarity and ownership."
        },
        {
            "question": "Which API Gateway responsibility helps prevent overloading services by limiting traffic?",
            "choices": ["A. Request Routing", "B. Response Aggregation", "C. Rate Limiting & Throttling", "D. Load Balancing"],
            "answer": "C",
            "reason": "Rate Limiting & Throttling in an API Gateway prevents overloading services by controlling the amount of traffic."
        },
        {
            "question": "Why is Service Discovery important in Microservices deployed in cloud environments?",
            "choices": ["A. Static IPs are used", "B. Containers and IPs change dynamically", "C. All services use fixed hostnames", "D. Services do not communicate with each other"],
            "answer": "B",
            "reason": "In cloud environments, services are often deployed in containers where IPs and ports can change dynamically, making Service Discovery essential."
        },
        {
            "question": "Which is NOT a core responsibility of an API Gateway?",
            "choices": ["A. Response Aggregation", "B. Authentication & Authorization", "C. Service Discovery", "D. Load Balancing"],
            "answer": "C",
            "reason": "Service Discovery is typically handled by a Service Registry, not directly by the API Gateway."
        },
        {
            "question": "Which is a key advantage of using gRPC over REST?",
            "choices": ["A. Simpler to debug manually", "B. More flexible versioning", "C. Strongly typed contracts and faster communication", "D. Supports XML-based payloads"],
            "answer": "C",
            "reason": "gRPC provides strongly typed contracts via Protocol Buffers and enables faster, more efficient communication with HTTP/2."
        },
        {
            "question": "Which gRPC feature supports real-time bidirectional communication?",
            "choices": ["A. RESTful APIs", "B. HTTP/1.1", "C. Streaming support over HTTP/2", "D. WebSockets"],
            "answer": "C",
            "reason": "gRPC supports real-time bidirectional streaming over HTTP/2, enabling efficient two-way communication."
        },
        {
            "question": "How does Service Discovery differ from Hardcoded Discovery?",
            "choices": ["A. Requires manual IP entry", "B. Enables dynamic lookup of services", "C. Requires static hostnames", "D. Makes services stateful"],
            "answer": "B",
            "reason": "Service Discovery enables dynamic lookup of services, whereas Hardcoded Discovery requires manual configuration of IPs/hostnames."
        },
        {
            "question": "How does SOA typically differ from Microservices in deployment?",
            "choices": ["A. SOA uses in-process calls only", "B. SOA typically uses centralized middleware (ESB), Microservices prefer decentralized communication", "C. Both deploy as monoliths", "D. Microservices are stateful only"],
            "answer": "B",
            "reason": "SOA often uses centralized middleware like an ESB, whereas Microservices promote decentralized, independently deployable services."
        },
        {
            "question": "Which is a key difference between REST and gRPC?",
            "choices": ["A. REST supports HTTP/2 natively", "B. gRPC uses JSON by default", "C. REST is text-based (JSON/XML), gRPC uses Protocol Buffers (binary)", "D. REST supports streaming better than gRPC"],
            "answer": "C",
            "reason": "REST typically uses text-based payloads (JSON/XML), while gRPC uses Protocol Buffers, a compact binary format."
        },
        {
            "question": "Which is an advantage of using an API Gateway?",
            "choices": ["A. Increases service coupling", "B. Reduces service discoverability", "C. Simplifies client-service communication", "D. Eliminates need for Service Registry"],
            "answer": "C",
            "reason": "An API Gateway simplifies client-service communication by acting as a single entry point and handling cross-cutting concerns like routing and auth."
        },
        {
            "question": "In terms of granularity, how does Component-Based Development (CBD) differ from SOA?",
            "choices": ["A. CBD uses coarse-grained services, SOA uses fine-grained components", "B. CBD uses fine/medium-grained components, SOA uses coarse-grained services", "C. Both use only fine-grained components", "D. Both use only in-process calls"],
            "answer": "B",
            "reason": "CBD typically uses fine/medium-grained components, while SOA focuses on coarse-grained, reusable services."
        },
        {
            "question": "Which coordination style in SOA uses a central controller to manage service interactions?",
            "choices": ["A. Choreography", "B. API Gateway", "C. Orchestration", "D. Point-to-Point"],
            "answer": "C",
            "reason": "Service Orchestration in SOA uses a central controller to coordinate interactions between services."
        },
        {
            "question": "How does Service Choreography differ from Orchestration?",
            "choices": ["A. Choreography uses a central controller", "B. Choreography allows services to interact via a global interaction protocol without central control", "C. Choreography requires an API Gateway", "D. Choreography is stateful"],
            "answer": "B",
            "reason": "In Service Choreography, services interact according to a global protocol without relying on a central controller."
        },
        {
            "question": "How does SOA typically differ from Microservices architecture?",
            "choices": ["A. SOA has decentralized communication only", "B. SOA services are typically independently deployable", "C. SOA often uses centralized middleware (ESB), Microservices promote decentralized, independently deployable services", "D. Both require monolithic databases"],
            "answer": "C",
            "reason": "SOA often uses centralized middleware like an ESB, while Microservices promote decentralized, independently deployable services."
        },
        {
            "question": "What is an advantage of using an API Gateway compared to having no gateway?",
            "choices": ["A. Requires manual client-service mapping", "B. Simplifies client-service communication through a single entry point", "C. Forces clients to implement service discovery", "D. Prevents dynamic routing"],
            "answer": "B",
            "reason": "An API Gateway simplifies client-service communication by providing a single entry point and handling concerns like routing, auth, and monitoring."
        },
        {
            "question": "How does Service Discovery differ from Hardcoded Discovery?",
            "choices": ["A. Hardcoded Discovery uses dynamic service lookup", "B. Service Discovery allows dynamic lookup of services, Hardcoded Discovery requires manual IP/hostname configuration", "C. Both require manual IP entry", "D. Both use static DNS"],
            "answer": "B",
            "reason": "Service Discovery allows services to dynamically discover each other, while Hardcoded Discovery requires manually configured IPs/hostnames."
        },
        {
            "question": "How does REST typically differ from gRPC?",
            "choices": ["A. REST uses HTTP/2 by default", "B. REST uses binary Protocol Buffers", "C. REST uses HTTP/1.1 and JSON (text), gRPC uses HTTP/2 and Protocol Buffers (binary)", "D. REST supports real-time streaming better than gRPC"],
            "answer": "C",
            "reason": "REST typically uses HTTP/1.1 with JSON (text-based), while gRPC uses HTTP/2 with Protocol Buffers (binary), making it more efficient."
        },
        {
            "question": "Which API communication style provides stronger contract enforcement?",
            "choices": ["A. REST with OpenAPI", "B. gRPC with proto files", "C. REST with XML", "D. REST with JSON"],
            "answer": "B",
            "reason": "gRPC provides stronger contract enforcement through strongly typed proto files."
        },
        {
            "question": "Which approach is generally faster in terms of payload and network efficiency?",
            "choices": ["A. REST with JSON", "B. REST with XML", "C. gRPC with Protocol Buffers", "D. SOAP with XML"],
            "answer": "C",
            "reason": "gRPC with Protocol Buffers provides faster and more efficient payloads compared to text-based formats like JSON or XML."
        },
        {
            "question": "Which architecture pattern usually favors event-driven communication and per-service databases?",
            "choices": ["A. SOA", "B. Layered Architecture", "C. Monolithic Architecture", "D. Microservices"],
            "answer": "D",
            "reason": "Microservices architecture typically favors event-driven communication and per-service databases to promote loose coupling and scalability."
        }
    ],
    "Lecture9: Microservices Deep Dive": [
        {
            "question": "What is a common challenge of communication in Microservices architectures?",
            "choices": ["A. All services run in a single process", "B. Many network calls between services", "C. Services never change IP addresses", "D. All services use a shared database"],
            "answer": "B",
            "reason": "One common challenge in Microservices architectures is that many network calls occur between services, introducing complexity and potential latency."
        },
        {
            "question": "What is a key benefit of using Database per Microservice?",
            "choices": ["A. Allows all services to share a single DB", "B. Enables loose coupling and service resilience", "C. Simplifies cross-service queries", "D. Requires no data duplication"],
            "answer": "B",
            "reason": "Database per Microservice enables loose coupling and service resilience by ensuring each service owns its own data."
        },
        {
            "question": "In Event Sourcing, how is the current state of an application determined?",
            "choices": ["A. Using the latest snapshot only", "B. By reading a shared database", "C. By replaying a sequence of stored immutable events", "D. By using REST calls"],
            "answer": "C",
            "reason": "In Event Sourcing, the current state of an application is determined by replaying a sequence of stored immutable events."
        },
        {
            "question": "What is a core concept of CQRS architecture?",
            "choices": ["A. Services always use shared databases", "B. Separation of read and write models", "C. All services share the same data model", "D. Single synchronous API for all operations"],
            "answer": "B",
            "reason": "CQRS (Command Query Responsibility Segregation) separates the read and write models, optimizing them independently."
        },
        {
            "question": "Why is 2-Phase Commit (2PC) generally not used in Microservices?",
            "choices": ["A. It is too simple", "B. It introduces tight coupling and performance overhead", "C. It is well-suited for distributed systems", "D. It guarantees eventual consistency"],
            "answer": "B",
            "reason": "2PC introduces tight coupling and significant performance overhead, making it unsuitable for modern cloud-native Microservices architectures."
        },
        {
            "question": "What is the purpose of the Saga Pattern in Microservices?",
            "choices": ["A. To implement ACID transactions", "B. To coordinate distributed transactions using compensating actions", "C. To share databases across services", "D. To ensure synchronous communication"],
            "answer": "B",
            "reason": "The Saga Pattern coordinates distributed transactions by using local transactions with compensating actions in case of failure."
        },
        {
            "question": "In a Saga Pattern, what is a characteristic of the Orchestration approach?",
            "choices": ["A. No central controller", "B. Services react to events asynchronously", "C. A central Saga orchestrator controls the workflow", "D. All services call each other directly"],
            "answer": "C",
            "reason": "In the Orchestration approach, a central Saga orchestrator controls the workflow of the distributed transaction."
        },
        {
            "question": "Why is Observability essential in Microservices?",
            "choices": ["A. Services always use a single thread", "B. Services do not communicate", "C. Services communicate asynchronously and scale dynamically", "D. Logs are unnecessary"],
            "answer": "C",
            "reason": "Observability is essential because services in Microservices architectures communicate asynchronously and can dynamically scale, making failures difficult to trace without proper monitoring."
        },
        {
            "question": "Which tool is commonly used to visualize Prometheus metrics?",
            "choices": ["A. Elasticsearch", "B. Kibana", "C. Grafana", "D. Jaeger"],
            "answer": "C",
            "reason": "Grafana is a visualization tool used to display Prometheus metrics through interactive dashboards."
        },
        {
            "question": "What does Spring Boot Actuator provide?",
            "choices": ["A. Real-time messaging between services", "B. API Gateway functionality", "C. Built-in endpoints for monitoring and management", "D. Data replication across services"],
            "answer": "C",
            "reason": "Spring Boot Actuator provides built-in endpoints for monitoring and management of Spring Boot applications."
        },
        {
            "question": "In CQRS, what does the Command model handle?",
            "choices": ["A. Read-only operations", "B. Data replication", "C. Create, Update, Delete operations", "D. Audit trail generation"],
            "answer": "C",
            "reason": "In CQRS, the Command model handles Create, Update, and Delete operations (write side)."
        },
        {
            "question": "What is a challenge of using CQRS?",
            "choices": ["A. Lack of read optimization", "B. Increased complexity due to synchronization logic", "C. Tight coupling between read and write models", "D. Shared database requirement"],
            "answer": "B",
            "reason": "A challenge of using CQRS is increased architectural complexity due to the need for synchronization logic and eventual consistency."
        },
        {
            "question": "How does Event Sourcing differ from traditional data management?",
            "choices": ["A. Only stores latest state", "B. Stores application state changes as immutable events", "C. Uses relational database constraints", "D. Disallows event replay"],
            "answer": "B",
            "reason": "Event Sourcing stores application state changes as immutable events, which can be replayed to reconstruct current state."
        },
        {
            "question": "What is a benefit of Event Sourcing?",
            "choices": ["A. Simplifies the database schema", "B. Provides a full audit trail and replayable state", "C. Guarantees immediate consistency", "D. Eliminates the need for caching"],
            "answer": "B",
            "reason": "Event Sourcing provides a full audit trail and allows the application state to be replayed at any time."
        },
        {
            "question": "In the Saga Pattern, what is a characteristic of Choreography?",
            "choices": ["A. Central controller manages workflow", "B. Services directly invoke each other", "C. Services listen to events and react without a central controller", "D. Centralized compensation logic"],
            "answer": "C",
            "reason": "In Choreography, services listen to events and react to them, without the need for a central controller."
        },
        {
            "question": "Which type of Saga is harder to visualize as a complete flow?",
            "choices": ["A. Orchestration Saga", "B. Choreography Saga", "C. 2PC", "D. ACID transaction"],
            "answer": "B",
            "reason": "In Choreography Sagas, the event flow is harder to visualize because there is no centralized orchestration."
        },
        {
            "question": "How does 2PC differ from the Saga Pattern?",
            "choices": ["A. 2PC is optimized for cloud-native systems", "B. 2PC uses compensating transactions", "C. Saga Pattern uses compensating transactions, 2PC uses locks and a coordinator", "D. Both are the same"],
            "answer": "C",
            "reason": "The Saga Pattern uses compensating transactions to handle failures, while 2PC relies on distributed locks and a coordinator, which is less scalable."
        },
        {
            "question": "What is the main focus of metrics in observability?",
            "choices": ["A. Detailed request/response content", "B. Distributed tracing", "C. Performance visibility through time-series data", "D. Detailed stack traces"],
            "answer": "C",
            "reason": "Metrics provide performance visibility through time-series data (such as CPU usage, request counts, latency)."
        },
        {
            "question": "Which observability tool type is used for Root Cause Analysis across services?",
            "choices": ["A. Metrics", "B. Logs", "C. Traces", "D. Caching"],
            "answer": "C",
            "reason": "Traces are used for Root Cause Analysis across services by following the path of a single request through the system."
        },
        {
            "question": "What is the difference between Logs and Metrics?",
            "choices": ["A. Logs are time-series data, Metrics are unstructured text", "B. Logs capture detailed event information, Metrics provide aggregate time-series data", "C. Metrics capture stack traces, Logs capture numeric counters", "D. They are identical"],
            "answer": "B",
            "reason": "Logs capture detailed event and error information, while Metrics provide aggregate time-series data for system performance."
        },
        {
            "question": "How does Event Sourcing differ from Traditional Data Management?",
            "choices": ["A. Event Sourcing stores current state only, Traditional stores all history", "B. Event Sourcing stores state changes as events, Traditional stores current state directly", "C. Event Sourcing uses relational DB only, Traditional uses NoSQL", "D. They are identical"],
            "answer": "B",
            "reason": "Event Sourcing stores state changes as immutable events, while Traditional Data Management stores only the current state directly in a database."
        },
        {
            "question": "What is a key benefit of Event Sourcing over Traditional Data Management?",
            "choices": ["A. Immediate consistency", "B. Simplified read models", "C. Full audit trail and replayability", "D. Simpler architecture"],
            "answer": "C",
            "reason": "A key benefit of Event Sourcing is that it provides a full audit trail of state changes and allows replaying those events to reconstruct state."
        },
        {
            "question": "How does CQRS differ from Traditional CRUD?",
            "choices": ["A. CQRS uses a single model for reads and writes", "B. CQRS separates read and write models, Traditional CRUD uses a single model", "C. CQRS requires shared database access, Traditional CRUD does not", "D. They are identical"],
            "answer": "B",
            "reason": "CQRS separates the read and write models to optimize them independently, while Traditional CRUD uses a single unified model for both."
        },
        {
            "question": "What is a key benefit of CQRS compared to Traditional CRUD?",
            "choices": ["A. Simplified architecture", "B. Guaranteed strong consistency", "C. Optimized performance and scalability through separate models", "D. Eliminates need for caching"],
            "answer": "C",
            "reason": "CQRS provides optimized performance and scalability by separating the command (write) and query (read) models."
        },
        {
            "question": "How does 2-Phase Commit (2PC) differ from the Saga Pattern?",
            "choices": ["A. 2PC uses compensating transactions", "B. Saga Pattern uses compensating transactions, 2PC uses distributed locks and coordination", "C. Both ensure immediate consistency", "D. Both are fully cloud-native"],
            "answer": "B",
            "reason": "The Saga Pattern ensures eventual consistency using compensating transactions, whereas 2PC uses distributed locks and a coordinator, which is less scalable."
        },
        {
            "question": "Which approach is more suitable for cloud-native, scalable Microservices?",
            "choices": ["A. 2PC", "B. Traditional ACID transactions", "C. Saga Pattern", "D. Synchronous 2PC"],
            "answer": "C",
            "reason": "The Saga Pattern is more suitable for cloud-native Microservices because it avoids distributed locks and allows eventual consistency through local transactions."
        },
        {
            "question": "In Saga Patterns, how does Orchestration differ from Choreography?",
            "choices": ["A. Orchestration is fully decentralized", "B. Choreography uses a central orchestrator", "C. Orchestration uses a central controller to manage the workflow, Choreography does not", "D. Both are fully centralized"],
            "answer": "C",
            "reason": "Orchestration uses a central controller to manage the Saga workflow, while Choreography is decentralized and driven by events."
        },
        {
            "question": "What is a key drawback of Choreography Saga compared to Orchestration?",
            "choices": ["A. Tight coupling between services", "B. Harder to visualize complete flow", "C. Requires central controller", "D. Guarantees immediate consistency"],
            "answer": "B",
            "reason": "A key drawback of Choreography Sagas is that the flow becomes harder to visualize as there is no centralized orchestration."
        },
        {
            "question": "What is the primary focus of Metrics in observability?",
            "choices": ["A. Detailed error stack traces", "B. Tracing the full path of a request", "C. Aggregate time-series performance data", "D. Detailed HTTP request payloads"],
            "answer": "C",
            "reason": "Metrics focus on providing aggregate time-series performance data, such as latency, error rates, CPU usage, etc."
        },
        {
            "question": "How do Logs differ from Traces in observability?",
            "choices": ["A. Logs capture request paths, Traces capture time-series data", "B. Logs capture detailed event and error information, Traces follow the flow of a request across services", "C. Both capture time-series metrics", "D. Both are used for real-time dashboards only"],
            "answer": "B",
            "reason": "Logs capture detailed event and error information for a system, while Traces follow the flow of a request across multiple services."
        }
    ],
    "Lecture10: Component Testing & Validation": [
        {
            "question": "What fundamental principle explains why testing can never prove a program is bug-free?",
            "choices": ["A. Turing’s Halting Problem", "B. Moore’s Law", "C. The CAP Theorem", "D. The Law of Demeter"],
            "answer": "A",
            "reason": "Turing’s Halting Problem shows that it is impossible to prove via testing that a program is completely bug-free — testing can only show the presence of bugs, not their absence."
        },
        {
            "question": "What is the primary goal of Unit Testing?",
            "choices": ["A. Test full application flow", "B. Test external APIs", "C. Test individual units in isolation", "D. Test component clusters"],
            "answer": "C",
            "reason": "The primary goal of Unit Testing is to test individual units (methods, classes) in isolation."
        },
        {
            "question": "Which of the following is a best practice for Unit Testing?",
            "choices": ["A. Share test state across tests", "B. Avoid mocking external dependencies", "C. Test one unit at a time", "D. Skip edge cases to focus on core paths"],
            "answer": "C",
            "reason": "A best practice in Unit Testing is to test one unit at a time and mock external dependencies to ensure isolation."
        },
        {
            "question": "What is Component Testing primarily used to validate?",
            "choices": ["A. Individual algorithms only", "B. The internal logic of a single method", "C. Functional correctness of a component and its interfaces", "D. End-to-end user flows"],
            "answer": "C",
            "reason": "Component Testing validates the functional correctness of a component and its exposed interfaces."
        },
        {
            "question": "How does Component Testing differ from Unit Testing?",
            "choices": ["A. Component Testing uses only mocks", "B. Component Testing tests individual units", "C. Component Testing tests integrated units as a single component", "D. They are the same"],
            "answer": "C",
            "reason": "Component Testing tests integrated units as a single component, focusing on their interactions and exposed behavior."
        },
        {
            "question": "What is the purpose of using Mockito in testing?",
            "choices": ["A. To test user interfaces", "B. To mock and simulate the behavior of real objects", "C. To perform end-to-end tests", "D. To generate test data automatically"],
            "answer": "B",
            "reason": "Mockito is used to mock and simulate the behavior of real objects during tests to isolate the logic under test."
        },
        {
            "question": "Which type of testing focuses on verifying interactions between modules?",
            "choices": ["A. Unit Testing", "B. Component Testing", "C. Integration Testing", "D. Manual Testing"],
            "answer": "C",
            "reason": "Integration Testing focuses on verifying the correctness of interactions between modules after they are combined."
        },
        {
            "question": "In Integration Testing, what is a best practice?",
            "choices": ["A. Test internal logic of components", "B. Use only mocks for all dependencies", "C. Simulate real user interactions and failure scenarios", "D. Skip HTTP calls"],
            "answer": "C",
            "reason": "A best practice for Integration Testing is to simulate real user interactions and include failure scenarios to validate cross-component workflows."
        },
        {
            "question": "What is the purpose of End-to-End (E2E) Testing?",
            "choices": ["A. Test individual units in isolation", "B. Verify full application flow from user input to output", "C. Test internal data models", "D. Only test backend APIs"],
            "answer": "B",
            "reason": "End-to-End Testing verifies the full application flow from user input through backend services to final output."
        },
        {
            "question": "Which type of testing is most useful for visual and UX validation?",
            "choices": ["A. Unit Testing", "B. Integration Testing", "C. Manual Testing", "D. Performance Testing"],
            "answer": "C",
            "reason": "Manual Testing is most useful for visual and UX validation, exploratory testing, and complex scenarios requiring human judgment."
        },
        {
            "question": "Which type of Performance Testing checks how the system performs under expected load?",
            "choices": ["A. Spike Testing", "B. Stress Testing", "C. Load Testing", "D. Endurance Testing"],
            "answer": "C",
            "reason": "Load Testing checks how the system performs under expected, normal load conditions."
        },
        {
            "question": "Which Performance Testing type tests the system's stability under a long, constant load?",
            "choices": ["A. Spike Testing", "B. Endurance Testing", "C. Load Testing", "D. Stress Testing"],
            "answer": "B",
            "reason": "Endurance Testing (also called Soak Testing) checks the system’s stability and resource usage under a long, constant load."
        },
        {
            "question": "Which testing type focuses on testing a single component’s correctness and its interfaces?",
            "choices": ["A. Unit Testing", "B. Integration Testing", "C. Component Testing", "D. Performance Testing"],
            "answer": "C",
            "reason": "Component Testing tests the correctness of a single component, focusing on its internal behavior and interfaces."
        },
        {
            "question": "How does Integration Testing differ from Component Testing?",
            "choices": ["A. Integration Testing tests individual units", "B. Integration Testing verifies interactions between multiple components or systems", "C. Integration Testing mocks all dependencies", "D. They are identical"],
            "answer": "B",
            "reason": "Integration Testing verifies interactions between multiple components or systems and their data flow."
        },
        {
            "question": "How does E2E Testing differ from Integration Testing?",
            "choices": ["A. E2E Testing verifies full application flow from user input to output", "B. E2E Testing tests individual units", "C. E2E Testing uses only mocked services", "D. They are the same"],
            "answer": "A",
            "reason": "E2E Testing verifies the full application flow from user input through the backend and output, simulating real user behavior."
        },
        {
            "question": "How does Manual Testing differ from Automated Testing?",
            "choices": ["A. Manual Testing runs test cases automatically", "B. Automated Testing requires human observation", "C. Manual Testing involves manual execution by testers", "D. They are identical"],
            "answer": "C",
            "reason": "Manual Testing involves manual execution of test cases by human testers, while Automated Testing runs test cases automatically through scripts."
        },
        {
            "question": "Which type of Performance Testing helps determine system behavior during sudden large changes in load?",
            "choices": ["A. Spike Testing", "B. Load Testing", "C. Stress Testing", "D. Volume Testing"],
            "answer": "A",
            "reason": "Spike Testing helps determine how a system behaves when sudden large changes in load occur."
        },
        {
            "question": "Which tool is specifically designed for Performance Testing of Web apps and APIs?",
            "choices": ["A. Mockito", "B. Selenium", "C. Apache JMeter", "D. JUnit"],
            "answer": "C",
            "reason": "Apache JMeter is a popular tool specifically designed for Performance Testing of web applications, APIs, and databases."
        },
        {
            "question": "What is a common downside of E2E Testing?",
            "choices": ["A. It cannot simulate real user behavior", "B. It is too fast and efficient", "C. It is brittle and UI changes can easily break tests", "D. It replaces the need for Unit Testing"],
            "answer": "C",
            "reason": "A common downside of E2E Testing is that it can be brittle—small UI changes can easily break tests."
        },
        {
            "question": "How does Load Testing differ from Stress Testing?",
            "choices": ["A. Load Testing checks performance under expected load, Stress Testing tests beyond expected limits", "B. Load Testing is only manual", "C. Stress Testing is used only in development", "D. They are identical"],
            "answer": "A",
            "reason": "Load Testing checks performance under expected load, while Stress Testing pushes the system beyond expected load to find breaking points."
        },
        {
            "question": "How does Unit Testing differ from Component Testing?",
            "choices": ["A. Unit Testing tests a component’s full functionality", "B. Component Testing tests individual units in isolation", "C. Unit Testing tests individual units, Component Testing tests integrated units as a single component", "D. They are identical"],
            "answer": "C",
            "reason": "Unit Testing focuses on individual units in isolation, whereas Component Testing validates integrated units as a single component."
        },
        {
            "question": "How does Component Testing differ from Integration Testing?",
            "choices": ["A. Component Testing validates interactions between multiple systems", "B. Component Testing focuses on a single component with controlled dependencies", "C. Integration Testing uses mocks for all dependencies", "D. They are the same"],
            "answer": "B",
            "reason": "Component Testing focuses on validating a single component with controlled dependencies, while Integration Testing verifies interactions between multiple components or systems."
        },
        {
            "question": "How does E2E Testing differ from Integration Testing?",
            "choices": ["A. E2E Testing verifies full application flow from user input to output", "B. Integration Testing is fully manual", "C. E2E Testing tests only APIs", "D. Integration Testing is not needed when E2E Testing is done"],
            "answer": "A",
            "reason": "E2E Testing verifies the full application flow from user input to final output, including all system layers."
        },
        {
            "question": "How does Manual Testing differ from Automated Testing?",
            "choices": ["A. Manual Testing uses automated scripts", "B. Automated Testing is executed by human testers", "C. Manual Testing involves manual execution by testers, Automated Testing runs scripts automatically", "D. Both are executed manually"],
            "answer": "C",
            "reason": "Manual Testing involves manual execution by testers, whereas Automated Testing runs scripts automatically to validate software behavior."
        },
        {
            "question": "What is the focus of Load Testing?",
            "choices": ["A. Testing system behavior under sudden load spikes", "B. Testing system under expected, normal load", "C. Testing for long-term endurance", "D. Testing system under minimal load"],
            "answer": "B",
            "reason": "Load Testing focuses on verifying the system’s performance under expected, normal load."
        },
        {
            "question": "What is the focus of Stress Testing?",
            "choices": ["A. Testing system under expected load", "B. Testing system with sudden load changes", "C. Testing system behavior beyond expected load limits", "D. Testing for UI/UX correctness"],
            "answer": "C",
            "reason": "Stress Testing focuses on testing the system’s behavior when pushed beyond its expected load limits."
        },
        {
            "question": "What is the focus of Spike Testing?",
            "choices": ["A. Testing behavior under sustained high load", "B. Testing with a sudden increase/decrease in load", "C. Testing under expected load", "D. Testing after code refactoring"],
            "answer": "B",
            "reason": "Spike Testing focuses on testing the system’s behavior under sudden increases and decreases in load."
        },
        {
            "question": "Which Performance Testing tool is best known for web apps, APIs, and database testing?",
            "choices": ["A. Mockito", "B. Apache JMeter", "C. Selenium", "D. JUnit"],
            "answer": "B",
            "reason": "Apache JMeter is widely used for Performance Testing of web apps, APIs, and databases."
        },
        {
            "question": "Which Performance Testing tool is known for being highly programmable and Python-based?",
            "choices": ["A. Locust", "B. k6", "C. Selenium", "D. TestCafe"],
            "answer": "A",
            "reason": "Locust is a programmable, Python-based Performance Testing tool used for load and scalability testing."
        },
        {
            "question": "Which Performance Testing tool is best suited for high concurrency and CI-friendly testing?",
            "choices": ["A. Gatling", "B. Apache JMeter", "C. Blazemeter", "D. Selenium"],
            "answer": "A",
            "reason": "Gatling is a Performance Testing tool known for its high concurrency support and CI-friendly architecture."
        }
    ],
    "Likely-Exam Questions": [
        {
            "question": "In CBSE, what does a Component Adapter do?",
            "choices": ["A. Provides services to a component", "B. Registers components in a repository", "C. Bridges incompatible component interfaces", "D. Loads components dynamically"],
            "answer": "C",
            "reason": "A Component Adapter bridges incompatible component interfaces so that components can work together despite interface mismatches."
        },
        {
            "question": "Which key principle is used to achieve loose coupling in Component-Based Software Engineering?",
            "choices": ["A. Static linking", "B. Centralized state management", "C. Dependency Injection", "D. Global variables"],
            "answer": "C",
            "reason": "Dependency Injection (DI) achieves loose coupling by allowing components to depend on interfaces rather than concrete implementations."
        },
        {
            "question": "How does a Microservices architecture typically differ from SOA?",
            "choices": ["A. Microservices use central orchestration", "B. Microservices are stateful by default", "C. Microservices favor decentralized, independently deployable services", "D. SOA uses stateless services exclusively"],
            "answer": "C",
            "reason": "Microservices favor decentralized, independently deployable services, while SOA often uses centralized orchestration and can be more heavyweight."
        },
        {
            "question": "What is the main benefit of using Event Sourcing in Microservices?",
            "choices": ["A. Shared database between services", "B. Immediate consistency", "C. Full audit trail and ability to replay state", "D. Simplified architecture"],
            "answer": "C",
            "reason": "Event Sourcing stores immutable events, providing a full audit trail and the ability to rebuild current state by replaying events."
        },
        {
            "question": "In the Saga Pattern, which approach uses a central controller to manage transaction flow?",
            "choices": ["A. Choreography", "B. Orchestration", "C. Whiteboard Pattern", "D. Service Locator Pattern"],
            "answer": "B",
            "reason": "Orchestration uses a central controller (Saga orchestrator) to manage the flow of distributed transactions."
        },
        {
            "question": "Which observability tool stack is primarily used for collecting and visualizing time-series metrics?",
            "choices": ["A. ELK Stack", "B. Prometheus + Grafana", "C. Jaeger", "D. WireMock"],
            "answer": "B",
            "reason": "Prometheus collects time-series metrics, and Grafana visualizes them via interactive dashboards."
        },
        {
            "question": "What is a primary characteristic of RESTful APIs?",
            "choices": ["A. Stateful server architecture", "B. Tight client-server coupling", "C. Stateless communication", "D. Requires gRPC for communication"],
            "answer": "C",
            "reason": "RESTful APIs are based on stateless communication, meaning each request contains all necessary information and the server does not retain client state."
        },
        {
            "question": "How does Component Testing differ from Integration Testing?",
            "choices": ["A. Component Testing verifies full application flow", "B. Component Testing tests one component with controlled dependencies, Integration Testing verifies interactions between components", "C. Component Testing uses real services only", "D. They are identical"],
            "answer": "B",
            "reason": "Component Testing focuses on testing one component with controlled dependencies, while Integration Testing verifies interactions between components or systems."
        },
        {
            "question": "Which type of Performance Testing tests system behavior under a long, constant load?",
            "choices": ["A. Spike Testing", "B. Endurance Testing", "C. Stress Testing", "D. Load Testing"],
            "answer": "B",
            "reason": "Endurance Testing (also called Soak Testing) evaluates how a system performs under a sustained, constant load for an extended period."
        },
        {
            "question": "What is a key difference between REST and gRPC?",
            "choices": ["A. REST uses HTTP/2 by default", "B. gRPC uses JSON payloads", "C. REST is text-based (JSON/XML), gRPC uses binary Protocol Buffers", "D. REST requires centralized orchestration"],
            "answer": "C",
            "reason": "REST typically uses text-based formats such as JSON or XML, while gRPC uses binary Protocol Buffers for more efficient communication."
        },
        {
            "question": "How does the Liskov Substitution Principle (LSP) affect software design?",
            "choices": ["A. Subclasses must be implemented as abstract classes", "B. Subclasses must be interchangeable with their superclass without affecting correctness", "C. Subclasses must override all superclass methods", "D. Subclasses must throw new exceptions"],
            "answer": "B",
            "reason": "LSP states that subclasses must be usable interchangeably with their superclass, ensuring behavioral consistency."
        },
        {
            "question": "How does the Decorator Pattern add behavior to objects?",
            "choices": ["A. By modifying the base class directly", "B. By inheritance only", "C. By adding behavior at runtime using composition", "D. By adding methods through AspectJ"],
            "answer": "C",
            "reason": "The Decorator Pattern adds behavior to objects at runtime through composition, not inheritance."
        },
        {
            "question": "What is the role of the Service Locator Pattern?",
            "choices": ["A. To manage application security", "B. To act as a central registry for discovering services", "C. To perform database transactions", "D. To validate service contracts"],
            "answer": "B",
            "reason": "The Service Locator Pattern provides a central registry where services can be registered and discovered at runtime."
        },
        {
            "question": "How does Java Platform Module System (JPMS) improve dependency management?",
            "choices": ["A. By enforcing dynamic service discovery", "B. By allowing multiple versions of the same class", "C. By providing strong encapsulation and compile-time dependency checking", "D. By eliminating the need for ServiceLoader"],
            "answer": "C",
            "reason": "JPMS provides strong encapsulation and enables compile-time dependency checking, solving issues like classpath hell."
        },
        {
            "question": "What is a key benefit of using a Multi-Module Maven Project?",
            "choices": ["A. Enforces monolithic builds", "B. Simplifies database schema management", "C. Encapsulates reusable components for efficient builds and dependency management", "D. Forces static linking"],
            "answer": "C",
            "reason": "Multi-Module Maven Projects encapsulate reusable components and provide efficient build and dependency management."
        },
        {
            "question": "How does an API Gateway benefit Microservices architecture?",
            "choices": ["A. Allows services to discover each other", "B. Acts as a single entry point and manages cross-cutting concerns", "C. Forces synchronous communication", "D. Adds extra latency to all calls"],
            "answer": "B",
            "reason": "An API Gateway acts as a single entry point for clients and handles cross-cutting concerns such as authentication, rate limiting, and request routing."
        },
        {
            "question": "How does Service Discovery improve Microservices scalability?",
            "choices": ["A. By forcing services to be stateful", "B. By allowing services to dynamically locate each other without hardcoded configurations", "C. By using static IP addresses", "D. By eliminating API Gateway requirements"],
            "answer": "B",
            "reason": "Service Discovery allows services to dynamically locate each other without hardcoded configurations, which is essential in scalable, dynamic environments like the cloud."
        },
        {
            "question": "How does Layered Architecture differ from Event-Driven Architecture (EDA)?",
            "choices": ["A. Layered uses asynchronous events, EDA uses synchronous calls", "B. Layered is synchronous and tightly coupled, EDA is asynchronous and loosely coupled", "C. Both use stateless services only", "D. EDA requires SOAP for communication"],
            "answer": "B",
            "reason": "Layered Architecture typically uses synchronous calls and has tighter coupling, while EDA relies on asynchronous events and achieves loose coupling."
        },
        {
            "question": "How does 2-Phase Commit (2PC) differ from the Saga Pattern?",
            "choices": ["A. 2PC uses compensating transactions, Saga Pattern uses global locks", "B. 2PC requires distributed locks and coordination, Saga Pattern uses local transactions with compensating actions", "C. Both use centralized orchestrators", "D. Both guarantee strong consistency"],
            "answer": "B",
            "reason": "2PC requires distributed locks and a coordinator, which introduces tight coupling and poor scalability, whereas the Saga Pattern uses local transactions with compensating actions and fits cloud-native architecture better."
        },
        {
            "question": "How does Automated Testing differ from Manual Testing?",
            "choices": ["A. Automated Testing is performed manually by testers", "B. Automated Testing runs predefined scripts, Manual Testing involves human testers executing test cases", "C. Automated Testing cannot be used in CI/CD pipelines", "D. Manual Testing is faster for regression suites"],
            "answer": "B",
            "reason": "Automated Testing runs predefined test scripts automatically, whereas Manual Testing involves human testers executing test cases manually."
        },
        {
            "question": "Where does Mockito add value in Unit and Component Testing?",
            "choices": ["A. It provides UI automation", "B. It mocks and simulates external dependencies", "C. It monitors network latency", "D. It acts as a distributed tracing tool"],
            "answer": "B",
            "reason": "Mockito is a Java mocking framework that allows you to simulate external dependencies to isolate the logic under test."
        },
        {
            "question": "In Aspect-Oriented Programming (AOP), what does an Aspect represent?",
            "choices": ["A. The base application logic", "B. A method argument", "C. An encapsulated cross-cutting concern", "D. A database transaction"],
            "answer": "C",
            "reason": "An Aspect in AOP represents an encapsulated cross-cutting concern such as logging, security, or transaction management."
        },
        {
            "question": "How does Layered Architecture differ from Component-Based Architecture?",
            "choices": ["A. Layered Architecture focuses on physical packaging, Component-Based focuses on logical layers", "B. Layered Architecture maps logical layers, Component-Based uses loosely coupled physical components", "C. Both use tight coupling", "D. Component-Based does not use DI"],
            "answer": "B",
            "reason": "Layered Architecture maps logical layers, while Component-Based Architecture implements loosely coupled physical components that can be independently deployed."
        },
        {
            "question": "How does Component-Based Development (CBD) differ from SOA?",
            "choices": ["A. CBD uses distributed services by default", "B. CBD uses coarse-grained services only", "C. CBD uses fine/medium-grained components and local deployment, SOA uses coarse-grained distributed services", "D. Both rely on REST APIs exclusively"],
            "answer": "C",
            "reason": "CBD focuses on fine/medium-grained components with local deployment, while SOA implements coarse-grained services distributed across a network."
        },
        {
            "question": "How does Orchestration differ from Choreography in a Saga Pattern?",
            "choices": ["A. Orchestration has no central controller", "B. Choreography is controlled centrally", "C. Orchestration uses a central controller to manage flow, Choreography is decentralized with event-based flow", "D. Both use distributed locks"],
            "answer": "C",
            "reason": "Orchestration uses a central controller to manage Saga workflow, while Choreography is decentralized and relies on services reacting to events."
        },
        {
            "question": "How does CQRS differ from Traditional CRUD?",
            "choices": ["A. CQRS uses a shared data model", "B. CQRS separates command (write) and query (read) models, Traditional CRUD uses a single model", "C. CRUD guarantees eventual consistency", "D. CQRS eliminates the need for read operations"],
            "answer": "B",
            "reason": "CQRS separates the command (write) and query (read) models for better scalability and performance, whereas Traditional CRUD uses a single unified model."
        },
        {
            "question": "What is a characteristic of Black-Box Component Composition?",
            "choices": ["A. The component’s internal logic is visible", "B. The component’s internal logic is hidden, interaction happens via public interfaces", "C. Component is tightly coupled", "D. Component must share its source code"],
            "answer": "B",
            "reason": "In Black-Box Component Composition, internal logic is hidden, and components interact only via well-defined public interfaces."
        },
        {
            "question": "What is one key Componentization Rule in CBSE?",
            "choices": ["A. Expose internal classes directly", "B. Group business functionality into reusable components and expose it via interfaces", "C. Share global variables between components", "D. Always use static composition"],
            "answer": "B",
            "reason": "A core Componentization Rule is to group business functionality into reusable components and expose it through clean interfaces."
        },
        {
            "question": "Which REST principle ensures that the server does not store any client session state?",
            "choices": ["A. Client-server separation", "B. Statelessness", "C. Uniform Interface", "D. Cacheability"],
            "answer": "B",
            "reason": "Statelessness is a REST principle that requires the server not to store any client session state between requests — each request must contain all necessary context."
        },
        {
            "question": "Which REST principle allows clients to improve performance by reusing responses?",
            "choices": ["A. Client-server separation", "B. Statelessness", "C. Cacheability", "D. Uniform Interface"],
            "answer": "C",
            "reason": "Cacheability allows clients to reuse server responses when appropriate, improving performance and reducing server load."
        },
        {
            "question": "In the Testing Pyramid, what is the role of Unit Testing?",
            "choices": ["A. Tests full application flow", "B. Tests interaction between modules", "C. Tests individual units in isolation", "D. Tests UX and visual aspects"],
            "answer": "C",
            "reason": "Unit Testing focuses on testing individual units (such as methods or classes) in complete isolation from other parts of the system."
        },
        {
            "question": "How does Component Testing differ from Integration Testing?",
            "choices": ["A. Component Testing validates full application flow", "B. Component Testing tests a single component in isolation or with controlled dependencies, Integration Testing verifies interaction between multiple components", "C. Component Testing requires full database integration", "D. Both are identical"],
            "answer": "B",
            "reason": "Component Testing tests a single component (including multiple units) with controlled dependencies, while Integration Testing validates how multiple components or modules interact."
        },
        {
            "question": "Which type of Performance Testing is used to test system behavior under sudden load increases or decreases?",
            "choices": ["A. Load Testing", "B. Stress Testing", "C. Spike Testing", "D. Endurance Testing"],
            "answer": "C",
            "reason": "Spike Testing evaluates how the system behaves when there are sudden large increases or decreases in load."
        },
        {
            "question": "How does a Component Model differ from a Component Framework?",
            "choices": ["A. Component Model manages runtime, Component Framework defines structure only", "B. Component Model defines structure, behavior, and interactions, Component Framework provides runtime support and lifecycle management", "C. They are the same", "D. Component Framework only manages versioning"],
            "answer": "B",
            "reason": "A Component Model defines structure, behavior, and interaction standards for components, while a Component Framework provides runtime support and manages component lifecycle and interactions."
        },
        {
            "question": "How does Dependency Injection differ from Service Locator?",
            "choices": ["A. Dependency Injection requires global variables", "B. Service Locator requires compile-time wiring", "C. Dependency Injection provides dependencies externally at runtime, Service Locator lets components look them up at runtime", "D. Both require JPMS modules"],
            "answer": "C",
            "reason": "Dependency Injection (DI) provides dependencies externally at runtime, while Service Locator allows components to look up required services at runtime."
        },
        {
            "question": "How does the Whiteboard Pattern differ from DI and Service Locator?",
            "choices": ["A. Whiteboard uses global variables", "B. Whiteboard publishes and consumes services dynamically with full decoupling, DI and Service Locator are more static", "C. Whiteboard is synchronous only", "D. Whiteboard forces inheritance"],
            "answer": "B",
            "reason": "The Whiteboard Pattern enables dynamic publishing and consumption of services, achieving high decoupling — DI and Service Locator tend to be more static in wiring."
        },
        {
            "question": "How does a Module differ from a Component?",
            "choices": ["A. Module focuses on physical behavior only", "B. Module organizes code and dependencies, Component focuses on behavior and functionality", "C. Module must always be stateful", "D. Component requires static composition"],
            "answer": "B",
            "reason": "A Module organizes code and manages dependencies (e.g. JPMS modules), while a Component focuses on encapsulating behavior and functionality that can be reused and deployed independently."
        },
        {
            "question": "How does using an API Gateway benefit client-service communication?",
            "choices": ["A. Requires clients to know all service endpoints", "B. Simplifies client interaction with services by providing a single entry point and handling cross-cutting concerns", "C. Forces all calls to go through synchronous REST", "D. Replaces the need for Service Discovery"],
            "answer": "B",
            "reason": "An API Gateway simplifies client-service communication by acting as a single entry point and managing concerns such as routing, authentication, rate limiting, and aggregation."
        },
        {
            "question": "How does Service Discovery differ from hardcoded service endpoints?",
            "choices": ["A. Hardcoded endpoints enable dynamic service lookup", "B. Service Discovery allows services to dynamically find each other, while hardcoded endpoints require manual configuration", "C. Both require Service Locator", "D. Both are static"],
            "answer": "B",
            "reason": "Service Discovery allows services to dynamically locate each other without relying on manually hardcoded IPs or hostnames."
        },
        {
            "question": "In Observability, what is the primary role of Traces?",
            "choices": ["A. Show CPU utilization trends", "B. Capture system logs", "C. Capture distributed flow of a request across multiple services", "D. Track memory usage"],
            "answer": "C",
            "reason": "Traces capture the distributed flow of a single request across multiple services, enabling root cause analysis and understanding of complex service interactions."
        },
        {
            "question": "In Component Composition, what is a characteristic of White-Box Composition?",
            "choices": ["A. The internal logic of the component is hidden", "B. The internal logic is visible and modifiable", "C. Components communicate only via events", "D. The component must be deployed as a black box"],
            "answer": "B",
            "reason": "White-Box Composition allows internal logic to be visible and modifiable, making it flexible but reducing encapsulation."
        },
        {
            "question": "How does Static Component Composition differ from Dynamic Component Composition?",
            "choices": ["A. Static composition happens at runtime", "B. Static composition requires DI", "C. Static composition happens at compile-time or build-time, Dynamic composition happens at runtime", "D. They are identical"],
            "answer": "C",
            "reason": "Static Component Composition happens at compile-time or build-time, while Dynamic Component Composition happens at runtime using mechanisms like DI or plugin loading."
        },
        {
            "question": "What is a key principle of the Liskov Substitution Principle (LSP)?",
            "choices": ["A. Subclasses must be abstract", "B. Subclasses must behave consistently with their superclass", "C. Subclasses must expose private methods", "D. Subclasses must add new required parameters"],
            "answer": "B",
            "reason": "LSP requires that subclasses behave consistently with their superclass, allowing them to be used interchangeably without breaking correctness."
        },
        {
            "question": "How does the Decorator Pattern add functionality to objects?",
            "choices": ["A. Through inheritance only", "B. By wrapping objects at runtime using composition", "C. By adding new static methods", "D. By overriding base class methods directly"],
            "answer": "B",
            "reason": "The Decorator Pattern adds functionality to objects by wrapping them at runtime using composition, allowing flexible behavior extension."
        },
        {
            "question": "In Event-Driven Architecture (EDA), how does the Mediator topology operate?",
            "choices": ["A. Fully decentralized with no central component", "B. Uses a central event orchestrator to manage event flow", "C. Forces all services to communicate synchronously", "D. Avoids any use of event queues"],
            "answer": "B",
            "reason": "The Mediator topology uses a central event orchestrator that manages the flow of events between producers and consumers."
        },
        {
            "question": "What is a key challenge of implementing CQRS?",
            "choices": ["A. Strong consistency is guaranteed", "B. Eventual consistency and sync logic complexity", "C. All services must share a database", "D. Read model and write model must be identical"],
            "answer": "B",
            "reason": "A key challenge of implementing CQRS is handling eventual consistency between the read and write models, and managing synchronization logic."
        },
        {
            "question": "What is a tradeoff of Event Sourcing?",
            "choices": ["A. Simplifies architecture significantly", "B. Provides immediate consistency always", "C. Introduces complexity in event versioning and separate read models", "D. Eliminates the need for messaging systems"],
            "answer": "C",
            "reason": "Event Sourcing introduces complexity in versioning events and maintaining separate read models to support different query requirements."
        },
        {
            "question": "In the Saga Pattern, what is an advantage of the Choreography approach?",
            "choices": ["A. Centralized workflow is enforced", "B. No central controller; services are loosely coupled via events", "C. All services must implement compensation logic centrally", "D. It uses distributed locks"],
            "answer": "B",
            "reason": "In Choreography, there is no central controller — services are loosely coupled and react to events, improving decoupling and flexibility."
        },
        {
            "question": "How does Manual Testing differ from Automated Testing?",
            "choices": ["A. Manual Testing requires no human involvement", "B. Automated Testing runs predefined test scripts, Manual Testing is executed manually by testers", "C. Automated Testing cannot be used in CI/CD", "D. Manual Testing is faster for large regression suites"],
            "answer": "B",
            "reason": "Manual Testing is executed manually by testers, while Automated Testing runs predefined test scripts automatically."
        },
        {
            "question": "How does gRPC differ from REST regarding contract enforcement?",
            "choices": ["A. REST has stronger contract enforcement", "B. gRPC uses strongly-typed proto files, REST uses less strict OpenAPI definitions", "C. Both rely on Protocol Buffers", "D. REST uses binary protocols only"],
            "answer": "B",
            "reason": "gRPC enforces contracts through strongly-typed proto files, while REST APIs often rely on less strict OpenAPI specifications or documentation."
        },
        {
            "question": "How does Black-Box Component Composition improve maintainability?",
            "choices": ["A. By exposing internal state of components", "B. By allowing direct modification of internal logic", "C. By enforcing interaction only via well-defined public interfaces", "D. By coupling components more tightly"],
            "answer": "C",
            "reason": "Black-Box Component Composition improves maintainability by ensuring components interact only through public interfaces, keeping internal logic hidden and changeable without affecting others."
        },
        {
            "question": "How does Dependency Depth impact coupling in Component-Based Systems?",
            "choices": ["A. Higher depth reduces coupling", "B. Higher depth increases coupling and reduces flexibility", "C. Dependency Depth is not related to coupling", "D. Lower depth always leads to tight coupling"],
            "answer": "B",
            "reason": "Higher Dependency Depth increases coupling and makes the system harder to maintain and test, reducing flexibility."
        },
        {
            "question": "How does DI help prevent tight coupling?",
            "choices": ["A. By using global variables", "B. By injecting concrete classes directly", "C. By injecting interfaces and letting the framework provide implementations", "D. By forcing compile-time binding"],
            "answer": "C",
            "reason": "DI prevents tight coupling by injecting interfaces, allowing implementations to be swapped externally without affecting the consumer code."
        },
        {
            "question": "In EDA, when would you prefer using Broker topology over Mediator?",
            "choices": ["A. When a centralized controller is required", "B. When maximum decoupling and dynamic event flow is desired", "C. When services must be invoked synchronously", "D. When orchestration must be centralized"],
            "answer": "B",
            "reason": "Broker topology allows maximum decoupling and dynamic event flow — services publish and subscribe without a central controller."
        },
        {
            "question": "Why is Database per Microservice considered a key principle?",
            "choices": ["A. It ensures global ACID transactions", "B. It forces all services to share data", "C. It ensures data ownership and isolation, enabling service autonomy", "D. It simplifies cross-service queries"],
            "answer": "C",
            "reason": "Database per Microservice ensures that each service owns and manages its own data, promoting autonomy and reducing coupling."
        },
        {
            "question": "What is a key tradeoff of having Database per Microservice?",
            "choices": ["A. Simplifies complex queries", "B. No need for event-driven communication", "C. Makes cross-service queries and consistency harder", "D. Guarantees immediate global consistency"],
            "answer": "C",
            "reason": "A tradeoff of Database per Microservice is that cross-service queries become harder and consistency must often be handled through eventual consistency patterns."
        },
        {
            "question": "In JPMS, what is the purpose of the 'requires' directive?",
            "choices": ["A. To declare which services the module provides", "B. To declare which modules this module depends on", "C. To specify public classes", "D. To manage DI injection"],
            "answer": "B",
            "reason": "In JPMS, the 'requires' directive declares which other modules this module depends on at compile time."
        },
        {
            "question": "Why is gRPC often preferred over REST for high-performance internal Microservices communication?",
            "choices": ["A. gRPC uses JSON payloads", "B. REST uses HTTP/2 by default", "C. gRPC uses HTTP/2 + binary Protocol Buffers, offering lower latency and more efficient communication", "D. REST supports built-in streaming"],
            "answer": "C",
            "reason": "gRPC uses HTTP/2 and binary Protocol Buffers, enabling lower latency and more efficient internal Microservices communication compared to REST with JSON."
        },
        {
            "question": "What is the main goal of Componentization in CBSE?",
            "choices": ["A. Increase tight coupling", "B. Enable component reuse, modularity, and maintainability", "C. Enforce central orchestration", "D. Promote inheritance over composition"],
            "answer": "B",
            "reason": "The goal of Componentization is to enable component reuse, modularity, and maintainability in complex software systems."
        },
        {
            "question": "How does Observability differ from simple Monitoring?",
            "choices": ["A. Observability only uses logs", "B. Monitoring focuses on known problems, Observability helps explore unknown system behavior", "C. Monitoring requires full traces, Observability does not", "D. Observability ignores metrics"],
            "answer": "B",
            "reason": "Monitoring focuses on known problems (alerting on predefined metrics), while Observability helps engineers explore unknown behavior and debug complex issues using metrics, logs, and traces."
        },
        {
            "question": "What is the role of a Provides Interface in Component-Based Systems?",
            "choices": ["A. To declare services the component consumes", "B. To define public services the component offers to others", "C. To define private internal methods", "D. To specify required third-party services"],
            "answer": "B",
            "reason": "A Provides Interface defines the public services that a component offers for use by other components."
        },
        {
            "question": "What is the role of a Requires Interface in Component-Based Systems?",
            "choices": ["A. To declare services the component offers", "B. To define internal services only", "C. To declare services the component depends on", "D. To expose public APIs"],
            "answer": "C",
            "reason": "A Requires Interface declares the services that a component depends on and expects to be provided by other components or the framework."
        },
        {
            "question": "What is a primary purpose of a Component Repository?",
            "choices": ["A. To enforce runtime dependency injection", "B. To centralize storage of components and their metadata", "C. To replace all uses of Maven", "D. To manage API Gateway routing"],
            "answer": "B",
            "reason": "A Component Repository serves as a central storage location for components, their metadata, and versioned artifacts."
        },
        {
            "question": "How does a Component Adapter differ from a Service Locator?",
            "choices": ["A. Component Adapter bridges incompatible component interfaces, Service Locator provides dynamic service lookup", "B. Both perform service discovery", "C. Component Adapter discovers services at runtime", "D. Service Locator modifies component behavior"],
            "answer": "A",
            "reason": "A Component Adapter bridges incompatible component interfaces so they can work together, while a Service Locator provides dynamic service lookup at runtime."
        },
        {
            "question": "How does Service Registry differ from Service Discovery?",
            "choices": ["A. Service Registry and Service Discovery are identical", "B. Service Registry is a database of service endpoints, Service Discovery is the process of clients querying it", "C. Service Discovery stores endpoint data", "D. Service Discovery eliminates the need for a registry"],
            "answer": "B",
            "reason": "A Service Registry is a database that stores service endpoints, and Service Discovery is the dynamic process by which clients query this registry to locate services."
        },
        {
            "question": "In Component Testing vs Integration Testing, what is a subtle difference?",
            "choices": ["A. Component Testing validates system-wide flows", "B. Integration Testing mocks all dependencies", "C. Component Testing focuses on correctness of one component with controlled dependencies, Integration Testing focuses on data flow between multiple real components", "D. They are always interchangeable"],
            "answer": "C",
            "reason": "Component Testing focuses on testing the correctness of a single component (potentially with mocks), while Integration Testing validates data flow between multiple real components or systems."
        },
        {
            "question": "Why is 2PC not widely used in Microservices?",
            "choices": ["A. It simplifies global transactions", "B. It requires global locks and tight coupling, harming scalability", "C. It uses eventual consistency", "D. It enables asynchronous messaging"],
            "answer": "B",
            "reason": "2PC requires distributed locks and tight coupling across services, which harms scalability and makes it unsuitable for modern Microservices architecture."
        },
        {
            "question": "What is a common misconception about API Gateway?",
            "choices": ["A. API Gateway replaces Service Discovery", "B. API Gateway is a single point of entry and does not replace Service Discovery", "C. API Gateway must perform DB joins", "D. API Gateway stores data"],
            "answer": "B",
            "reason": "A common misconception is that API Gateway replaces Service Discovery — it acts as a single point of entry but often still relies on Service Discovery to route requests dynamically."
        },
        {
            "question": "In AOP, what is the difference between Pointcut and Join Point?",
            "choices": ["A. Pointcut is a runtime method call, Join Point is an expression", "B. Pointcut matches Join Points, Join Point is an actual point in execution (e.g. method call)", "C. They are identical", "D. Pointcut performs advice logic"],
            "answer": "B",
            "reason": "A Pointcut is an expression that matches certain Join Points (specific points in execution such as method calls) where advice should be applied."
        },
        {
            "question": "What is a drawback of Layered Architecture?",
            "choices": ["A. Forces components to be stateless", "B. Forces cross-layer optimization", "C. Changes in one layer often require redeploying the entire application", "D. Prevents caching"],
            "answer": "C",
            "reason": "A drawback of Layered Architecture is that changes in one layer often require redeploying the entire application because the layers are tightly coupled and not deployed as independent components."
        },
        {
            "question": "How does a Component Adapter differ from Component Composition?",
            "choices": ["A. Component Adapter allows runtime loading of components", "B. Component Adapter bridges incompatible interfaces, Component Composition combines components into larger systems", "C. Component Composition is static only", "D. They are identical"],
            "answer": "B",
            "reason": "A Component Adapter bridges incompatible interfaces so components can interact, while Component Composition combines components into larger systems via defined composition patterns (sequential, hierarchical, additive)."
        },
        {
            "question": "What is the subtle difference between Dependency Injection (DI) and Inversion of Control (IoC)?",
            "choices": ["A. DI is a subset of IoC focusing on providing dependencies externally", "B. IoC is a subset of DI", "C. They are completely unrelated", "D. DI always requires Service Locator"],
            "answer": "A",
            "reason": "Dependency Injection is a form of Inversion of Control — IoC is the broader principle of framework-controlled flow, while DI specifically provides dependencies externally rather than having components construct them."
        },
        {
            "question": "In JPMS, what does 'exports' mean in module-info.java?",
            "choices": ["A. Declares required modules", "B. Specifies packages to expose to other modules", "C. Allows runtime reflection", "D. Declares service implementations"],
            "answer": "B",
            "reason": "The 'exports' directive specifies which packages in a module should be exposed to other modules."
        },
        {
            "question": "In JPMS, what does 'opens' mean in module-info.java?",
            "choices": ["A. Declares a required dependency", "B. Allows runtime reflection for frameworks like Spring", "C. Makes a service public", "D. Exports all module classes"],
            "answer": "B",
            "reason": "The 'opens' directive allows runtime reflection access to specific packages — this is used by frameworks like Spring for dependency injection and proxies."
        },
        {
            "question": "In CQRS, what is the primary distinction between Command and Query models?",
            "choices": ["A. Both models use the same database", "B. Command model handles write operations, Query model handles read operations", "C. Command model must use NoSQL", "D. Both models are identical"],
            "answer": "B",
            "reason": "In CQRS, the Command model handles create, update, and delete (write) operations, while the Query model handles read-only operations, allowing independent optimization."
        },
        {
            "question": "In EDA, when would a Mediator topology be preferred over Broker?",
            "choices": ["A. When maximum decoupling is required", "B. When event flow must be centrally coordinated", "C. When using REST only", "D. When Broker is not scalable"],
            "answer": "B",
            "reason": "Mediator topology is preferred when event flow needs to be centrally coordinated through an orchestrator that controls the sequence and routing of events."
        },
        {
            "question": "What is a key limitation of REST in complex enterprise scenarios?",
            "choices": ["A. REST cannot use HTTP/2", "B. REST lacks standardization for complex operations and versioning", "C. REST cannot perform CRUD operations", "D. REST requires SOAP"],
            "answer": "B",
            "reason": "REST lacks strict standardization for complex operations and versioning, which can make managing complex APIs more difficult in large enterprise scenarios."
        },
        {
            "question": "Which Testing Pyramid layer is most effective at catching logic errors in isolated units?",
            "choices": ["A. End-to-End Testing", "B. Integration Testing", "C. Component Testing", "D. Unit Testing"],
            "answer": "D",
            "reason": "Unit Testing is most effective for catching logic errors in isolated units, such as individual methods or classes."
        },
        {
            "question": "What is a best practice for Integration Testing?",
            "choices": ["A. Use mocks for all services", "B. Validate interaction between real components and services", "C. Focus only on unit logic", "D. Avoid HTTP calls"],
            "answer": "B",
            "reason": "Integration Testing best practices include validating interactions between real components and services to ensure correct data flow and behavior across system boundaries."
        },
        {
            "question": "Why should Component functionality be exposed via interfaces in Componentization Rules?",
            "choices": ["A. To enforce tight coupling", "B. To promote loose coupling and enable flexibility in implementations", "C. To allow runtime type checking", "D. To expose private state"],
            "answer": "B",
            "reason": "Exposing functionality via interfaces promotes loose coupling and allows the flexibility to change or replace implementations without affecting consumers."
        },
        {
            "question": "What is a key limitation of using ServiceLoader compared to modern DI frameworks?",
            "choices": ["A. ServiceLoader supports constructor injection", "B. ServiceLoader does not support DI scopes or lifecycle management", "C. ServiceLoader enforces compile-time wiring", "D. ServiceLoader supports field injection"],
            "answer": "B",
            "reason": "ServiceLoader lacks support for DI scopes, lifecycle management, and complex dependency graphs — modern DI frameworks like Spring provide these features."
        },
        {
            "question": "How does Component Testing subtly differ from Unit Testing?",
            "choices": ["A. Component Testing mocks all dependencies", "B. Component Testing validates integrated units as a component with controlled dependencies, Unit Testing tests isolated units only", "C. They are the same", "D. Unit Testing uses real databases"],
            "answer": "B",
            "reason": "Component Testing validates clusters of integrated units within a component and tests its interfaces and interactions, while Unit Testing focuses on isolated units (methods/classes)."
        },
        {
            "question": "When would you prefer Gray-Box Composition over Black-Box Composition?",
            "choices": ["A. When you want full encapsulation", "B. When you want no visibility into internal behavior", "C. When you want controlled visibility via metadata/configuration to customize behavior", "D. When you must avoid AOP"],
            "answer": "C",
            "reason": "Gray-Box Composition allows controlled visibility into internal component behavior via configuration or metadata, providing a balance between flexibility and encapsulation."
        },
        {
            "question": "In versioning Microservices vs Monoliths, what is a common challenge for Microservices?",
            "choices": ["A. Services can share database tables", "B. Versioning APIs and maintaining backward compatibility across independently deployed services", "C. Versioning is not needed", "D. Monoliths require more versioning effort"],
            "answer": "B",
            "reason": "In Microservices, each service is deployed independently, so maintaining backward compatibility and API versioning across services is a major challenge."
        },
        {
            "question": "What is a practical tradeoff of REST statelessness?",
            "choices": ["A. Simplifies server-side state management but may increase overhead by requiring more data per request", "B. Makes caching impossible", "C. Enforces global transaction scope", "D. Requires SOAP compatibility"],
            "answer": "A",
            "reason": "REST statelessness simplifies server-side state management and improves scalability, but it can increase request overhead because each request must contain all necessary context."
        },
        {
            "question": "In CQRS, what is a practical implication of eventual consistency?",
            "choices": ["A. The read model will reflect write changes immediately", "B. The read model may temporarily lag behind the write model", "C. The system guarantees strong consistency at all times", "D. No data duplication is allowed"],
            "answer": "B",
            "reason": "A practical implication of CQRS is that the read model may temporarily lag behind the write model — eventual consistency is expected in most CQRS implementations."
        },
        {
            "question": "What is a typical use case for Event-Driven Architecture (EDA)?",
            "choices": ["A. High-throughput real-time data pipelines and event-driven workflows", "B. Strict synchronous transaction processing", "C. Simplifying layered monoliths", "D. Avoiding all use of messaging systems"],
            "answer": "A",
            "reason": "EDA is ideal for high-throughput real-time data pipelines and systems where asynchronous event-driven workflows are required."
        },
        {
            "question": "What is a common misuse pattern of API Gateway?",
            "choices": ["A. Using it for centralized authentication", "B. Using it for routing", "C. Embedding heavy business logic inside the gateway", "D. Providing a single entry point"],
            "answer": "C",
            "reason": "A common misuse pattern is embedding heavy business logic inside the API Gateway — the gateway should focus on cross-cutting concerns, not business logic."
        },
        {
            "question": "How does Load Testing differ from Stress Testing in production scenario planning?",
            "choices": ["A. Load Testing validates behavior under expected load, Stress Testing explores system limits and failure points", "B. Stress Testing only measures response time", "C. Load Testing must simulate sudden spikes", "D. Stress Testing only applies to monoliths"],
            "answer": "A",
            "reason": "Load Testing validates system behavior under expected load, while Stress Testing explores the system’s limits and how it behaves when pushed beyond expected capacity."
        },
        {
            "question": "When is the Service Locator Pattern considered an anti-pattern?",
            "choices": ["A. When it is used to manage simple dependencies", "B. When it is used in combination with DI frameworks", "C. When it hides dependencies from the class interface, making the code harder to test and maintain", "D. When it supports service versioning"],
            "answer": "C",
            "reason": "Service Locator is considered an anti-pattern when it hides dependencies from the class interface — this makes code harder to test, maintain, and reason about."
        },
        {
            "question": "What is the primary purpose of a Component Model?",
            "choices": ["A. To enforce runtime reflection", "B. To define structure, behavior, and interaction standards for components", "C. To force stateless design", "D. To require specific communication protocols"],
            "answer": "B",
            "reason": "A Component Model defines structure, behavior, and interaction standards for components, ensuring interoperability and consistency."
        },
        {
            "question": "How does a modern Component Framework (like Spring) differ from EJB?",
            "choices": ["A. Component Frameworks are more heavyweight", "B. EJB does not support DI", "C. Component Frameworks are lightweight, flexible, and suitable for Microservices, EJB is heavyweight and tightly coupled", "D. EJB is required for REST APIs"],
            "answer": "C",
            "reason": "Modern Component Frameworks (Spring) are lightweight, flexible, and suitable for Microservices; EJB is heavyweight and tied to the Java EE platform."
        },
        {
            "question": "In AOP, what are the main types of Weaving?",
            "choices": ["A. Build-time, compile-time, load-time, runtime", "B. Unit-time only", "C. REST-time only", "D. SOAP-time only"],
            "answer": "A",
            "reason": "The main types of Weaving in AOP are build-time, compile-time, load-time, and runtime — this refers to when aspects are applied to the target code."
        },
        {
            "question": "How does the Whiteboard Model differ from DI and Service Locator?",
            "choices": ["A. Whiteboard uses static service bindings", "B. Whiteboard allows dynamic service publishing and consumption, while DI and Service Locator are more static", "C. Service Locator requires Whiteboard", "D. DI does not support loose coupling"],
            "answer": "B",
            "reason": "The Whiteboard Model enables dynamic publishing and consumption of services (high flexibility), while DI and Service Locator typically have more static wiring."
        },
        {
            "question": "What is a real-world benefit of using a Component Repository?",
            "choices": ["A. It simplifies thread management", "B. It enables easy sharing, versioning, and reuse of components across multiple projects", "C. It eliminates the need for APIs", "D. It forces the use of SOAP"],
            "answer": "B",
            "reason": "A Component Repository allows for easy sharing, versioning, and reuse of components across multiple projects and teams, improving efficiency and consistency."
        },
        {
            "question": "How does a Mediator-based EDA topology compare to an Orchestration Saga?",
            "choices": ["A. Mediator is synchronous only", "B. Mediator manages event flow, Orchestration Saga manages transaction flow with compensating transactions", "C. Mediator replaces database transactions", "D. Mediator always requires REST"],
            "answer": "B",
            "reason": "Mediator topology manages event flow in EDA, while Orchestration Saga explicitly manages transaction flow across distributed systems using compensating transactions."
        },
        {
            "question": "When should Event Sourcing and CQRS be combined?",
            "choices": ["A. Never — they are incompatible", "B. When full audit trail and flexible read models are needed", "C. When strict ACID consistency is required", "D. Only in SOAP-based systems"],
            "answer": "B",
            "reason": "Event Sourcing and CQRS are often combined when a full audit trail of state changes and flexible, optimized read models are needed — they complement each other well."
        },
        {
            "question": "What is a common pitfall of E2E Testing in the Testing Pyramid?",
            "choices": ["A. It always runs fast", "B. E2E Testing is fragile and can break easily with UI changes", "C. E2E Testing replaces all other layers", "D. E2E Testing cannot validate UI flows"],
            "answer": "B",
            "reason": "A common pitfall of E2E Testing is that it is fragile — small UI changes can easily break tests, making maintenance challenging."
        },
        {
            "question": "How do Prometheus and ELK Stack differ in observability focus?",
            "choices": ["A. Both only do logging", "B. Prometheus focuses on metrics, ELK focuses on logs", "C. Both focus on metrics only", "D. ELK Stack replaces tracing"],
            "answer": "B",
            "reason": "Prometheus focuses on collecting and querying metrics (numerical time-series data), while ELK Stack (Elasticsearch, Logstash, Kibana) focuses on aggregating, storing, and visualizing logs."
        },
        {
            "question": "In the Saga Pattern, what is the purpose of compensating transactions?",
            "choices": ["A. To optimize system performance", "B. To enforce synchronous workflows", "C. To undo previous steps if a failure occurs later in the Saga", "D. To manage REST caching"],
            "answer": "C",
            "reason": "Compensating transactions are used in the Saga Pattern to undo previous actions if a later step in the Saga fails — ensuring eventual consistency across distributed systems."
        }
    ]
}