{
    "Lecture1: Component-Based Systems": [
        {
            "question": "What is a core characteristic of a software component?",
            "choices": ["A. Requires a main method", "B. Is always a class", "C. Is independently deployable with well-defined interfaces", "D. Must use object-oriented inheritance"],
            "answer": "C",
            "reason": "A component is a reusable, independently deployable software unit with well-defined interfaces."
        },
        {
            "question": "What does CBSE stand for?",
            "choices": ["A. Centralized Binary Software Engineering", "B. Component-Based Software Engineering", "C. Component Binary System Engineering", "D. Core-Based System Engineering"],
            "answer": "B",
            "reason": "CBSE stands for Component-Based Software Engineering, an approach that builds systems using pre-existing, reusable components."
        },
        {
            "question": "Which term describes dividing a system into independent, self-contained parts?",
            "choices": ["A. Reusability", "B. Modularity", "C. Encapsulation", "D. Composition"],
            "answer": "B",
            "reason": "Modularity refers to dividing a system into independent, self-contained components."
        },
        {
            "question": "What is the purpose of encapsulation in a component?",
            "choices": ["A. To expose internal data for easy access", "B. To prevent the component from being reused", "C. To hide internal details and expose only public interfaces", "D. To enforce use of object inheritance"],
            "answer": "C",
            "reason": "Encapsulation hides the internal details of a component and exposes only the public interfaces."
        },
        {
            "question": "What defines structure, behavior, and interaction standards of components?",
            "choices": ["A. Component Model", "B. Component Framework", "C. Component Repository", "D. Component Adapter"],
            "answer": "A",
            "reason": "A Component Model defines the structure, behavior, and interaction standards of components."
        },
        {
            "question": "Which architecture pattern uses small, independent services often deployed via containers?",
            "choices": ["A. Monolithic Architecture", "B. Microservices Architecture", "C. CORBA", "D. Client-Server Architecture"],
            "answer": "B",
            "reason": "Microservices Architecture uses small, independent services often deployed via containers (e.g., Docker, Kubernetes)."
        },
        {
            "question": "What does a Component Adapter do?",
            "choices": ["A. Stores components in a central database", "B. Bridges incompatible component interfaces", "C. Provides deployment specifications", "D. Defines the component model"],
            "answer": "B",
            "reason": "A Component Adapter is a software element that bridges incompatible component interfaces."
        },
        {
            "question": "In component composition, which type involves components being called one after another by an external application?",
            "choices": ["A. Additive Composition", "B. Hierarchical Composition", "C. Sequential Composition", "D. Parallel Composition"],
            "answer": "C",
            "reason": "Sequential Composition involves components being called in sequence by an external application."
        },
        {
            "question": "Which of the following is an obsolete framework for cross-platform component communication?",
            "choices": ["A. CORBA", "B. SOA", "C. Microservices", "D. REST"],
            "answer": "A",
            "reason": "CORBA (Common Object Request Broker Architecture) is an obsolete framework that enabled components to communicate across languages and platforms."
        },
        {
            "question": "How do components differ from objects?",
            "choices": ["A. Components are lower-level constructs than objects", "B. Objects are reusable across systems, components are not", "C. Components are higher-level, coarse-grained reusable modules; objects are fine-grained instances of classes", "D. There is no difference between components and objects"],
            "answer": "C",
            "reason": "Components are higher-level, coarse-grained reusable modules, while objects are fine-grained instances of classes."
        },
        {
            "question": "Which of the following is the main benefit of reusability in CBSE?",
            "choices": ["A. Increased code complexity", "B. Reduced system performance", "C. Faster development and lower costs", "D. Increased need for manual testing"],
            "answer": "C",
            "reason": "Reusability allows components to be used across multiple systems, resulting in faster development and lower costs."
        },
        {
            "question": "Which term describes the ability to combine components to form larger systems?",
            "choices": ["A. Adaptability", "B. Composability", "C. Encapsulation", "D. Modularization"],
            "answer": "B",
            "reason": "Composability refers to the ability to combine components to form larger systems."
        },
        {
            "question": "What does a Component Repository typically store?",
            "choices": ["A. Source code only", "B. Executable files only", "C. Components, their metadata, and interfaces", "D. Deployment logs"],
            "answer": "C",
            "reason": "A Component Repository stores components, their metadata, and interfaces."
        },
        {
            "question": "What is an example of a Component Repository mentioned in the lecture?",
            "choices": ["A. Docker Hub", "B. GitHub", "C. Maven Central Repository", "D. NPM"],
            "answer": "C",
            "reason": "Maven Central Repository is an example of a Component Repository."
        },
        {
            "question": "Which interface type specifies services a component offers?",
            "choices": ["A. Requires Interface", "B. Adapter Interface", "C. Provides Interface", "D. Hidden Interface"],
            "answer": "C",
            "reason": "Provides Interface specifies the services a component offers to others."
        },
        {
            "question": "Which interface type specifies services a component needs from other components?",
            "choices": ["A. Requires Interface", "B. Adapter Interface", "C. Provides Interface", "D. Implementation Interface"],
            "answer": "A",
            "reason": "Requires Interface specifies the services a component needs from others."
        },
        {
            "question": "In which type of component composition does one component directly call another?",
            "choices": ["A. Sequential Composition", "B. Hierarchical Composition", "C. Additive Composition", "D. Parallel Composition"],
            "answer": "B",
            "reason": "Hierarchical Composition involves one component directly calling another component."
        },
        {
            "question": "In Additive Composition, components:",
            "choices": ["A. Call each other directly", "B. Call each other sequentially", "C. Do not call each other and operate independently", "D. Must share the same interface"],
            "answer": "C",
            "reason": "In Additive Composition, components do not call each other and operate independently."
        },
        {
            "question": "Which architecture involves services as stand-alone entities communicating via standard protocols?",
            "choices": ["A. Monolithic Architecture", "B. Service-Oriented Architecture (SOA)", "C. Microkernel Architecture", "D. MVC Architecture"],
            "answer": "B",
            "reason": "Service-Oriented Architecture (SOA) involves stand-alone services communicating via standard protocols like SOAP and REST."
        },
        {
            "question": "Which of the following statements about CORBA is correct?",
            "choices": ["A. CORBA is a modern framework based on REST APIs", "B. CORBA uses Object Request Brokers and IIOP", "C. CORBA is required for Microservices", "D. CORBA is a proprietary Microsoft technology"],
            "answer": "B",
            "reason": "CORBA (Common Object Request Broker Architecture) used Object Request Brokers (ORBs) and the Internet Inter-ORB Protocol (IIOP)."
        },
                {
            "question": "Which of the following best describes the granularity of Objects compared to Components?",
            "choices": ["A. Objects are coarse-grained; Components are fine-grained", "B. Both Objects and Components are fine-grained", "C. Objects are fine-grained; Components are coarse-grained", "D. Both Objects and Components are coarse-grained"],
            "answer": "C",
            "reason": "Objects are fine-grained instances of classes; Components are higher-level, coarse-grained reusable modules."
        },
        {
            "question": "In which architecture are services typically stateless and independently deployable?",
            "choices": ["A. SOA", "B. Microservices", "C. CORBA", "D. Monolithic"],
            "answer": "B",
            "reason": "Microservices architecture uses small, independently deployable services that are often stateless."
        },
        {
            "question": "Which architecture commonly uses SOAP as a communication protocol?",
            "choices": ["A. Microservices", "B. Component Model", "C. SOA", "D. Object-Oriented"],
            "answer": "C",
            "reason": "Service-Oriented Architecture (SOA) often uses SOAP as a standard communication protocol."
        },
        {
            "question": "Which of the following is true about Components in comparison to Objects?",
            "choices": ["A. Components are runtime instances of classes", "B. Objects are deployed independently", "C. Components are deployed independently with well-defined interfaces", "D. Objects and Components are interchangeable"],
            "answer": "C",
            "reason": "Components are independently deployable software units with well-defined interfaces, unlike typical objects."
        },
        {
            "question": "Which architecture pattern is more likely to utilize containerization technologies such as Docker?",
            "choices": ["A. Object-Oriented Architecture", "B. SOA", "C. Monolithic Architecture", "D. Microservices Architecture"],
            "answer": "D",
            "reason": "Microservices Architecture commonly uses containerization technologies like Docker and orchestration tools like Kubernetes."
        },
        {
            "question": "Which element defines the standards for structure, behavior, and interaction of components?",
            "choices": ["A. Component Framework", "B. Component Adapter", "C. Component Model", "D. Microservice"],
            "answer": "C",
            "reason": "The Component Model defines the structure, behavior, and interaction standards for components."
        },
        {
            "question": "Which element provides the runtime environment and manages lifecycle of components?",
            "choices": ["A. Component Model", "B. Component Repository", "C. Component Framework", "D. Microservice"],
            "answer": "C",
            "reason": "A Component Framework provides the runtime environment for components and manages their lifecycle and communication."
        },
        {
            "question": "In terms of service composition, which architecture often involves orchestration via an Enterprise Service Bus (ESB)?",
            "choices": ["A. Object-Oriented Architecture", "B. Microservices", "C. SOA", "D. Component Framework"],
            "answer": "C",
            "reason": "SOA often uses an Enterprise Service Bus (ESB) for orchestrating and mediating services."
        },
        {
            "question": "Which architecture typically emphasizes loose coupling and decentralized governance?",
            "choices": ["A. Object-Oriented", "B. SOA", "C. Microservices", "D. Monolithic"],
            "answer": "C",
            "reason": "Microservices architecture emphasizes loose coupling, decentralized data management, and independent governance of services."
        },
        {
            "question": "Which architecture tends to involve larger, more complex service contracts and centralized control?",
            "choices": ["A. Microservices", "B. Component Framework", "C. SOA", "D. Object-Oriented"],
            "answer": "C",
            "reason": "SOA often involves larger and more complex service contracts and centralized control mechanisms like ESB."
        }
    ],
    "Lecture2: Java Crash Course & Introduction to Maven": [
        {
            "question": "Which component of the JVM is responsible for loading classes?",
            "choices": ["A. Execution Engine", "B. Class Loader", "C. JIT Compiler", "D. Garbage Collector"],
            "answer": "B",
            "reason": "The Class Loader in the JVM is responsible for loading classes."
        },
        {
            "question": "What is the primary purpose of the Java Virtual Machine (JVM)?",
            "choices": ["A. Compile Java source code", "B. Interpret HTML files", "C. Execute Java bytecode on any platform", "D. Manage database connections"],
            "answer": "C",
            "reason": "The JVM executes Java bytecode on any platform, enabling Java's platform independence."
        },
        {
            "question": "Which Java component provides both the JVM and core libraries but no development tools?",
            "choices": ["A. JDK", "B. JRE", "C. IDE", "D. JVM"],
            "answer": "B",
            "reason": "The JRE provides the JVM and core libraries but does not include development tools."
        },
        {
            "question": "Which pillar of Object-Oriented Programming involves hiding implementation details and exposing only essential features?",
            "choices": ["A. Inheritance", "B. Polymorphism", "C. Abstraction", "D. Encapsulation"],
            "answer": "C",
            "reason": "Abstraction hides implementation details and exposes only the essential features."
        },
        {
            "question": "Which Java keyword is used to define a class that cannot be instantiated directly?",
            "choices": ["A. interface", "B. static", "C. abstract", "D. final"],
            "answer": "C",
            "reason": "An abstract class cannot be instantiated directly and is used to define common behavior."
        },
        {
            "question": "Which keyword is used to indicate a method or variable is accessible everywhere?",
            "choices": ["A. private", "B. protected", "C. public", "D. package-private"],
            "answer": "C",
            "reason": "The public keyword makes a method or variable accessible from anywhere."
        },
        {
            "question": "What type of polymorphism is achieved through method overloading?",
            "choices": ["A. Runtime polymorphism", "B. Dynamic polymorphism", "C. Compile-time polymorphism", "D. Late binding polymorphism"],
            "answer": "C",
            "reason": "Method overloading achieves compile-time polymorphism."
        },
        {
            "question": "In Java, what is the purpose of the `finally` block in exception handling?",
            "choices": ["A. To catch exceptions", "B. To throw exceptions", "C. To always execute cleanup code", "D. To skip code execution"],
            "answer": "C",
            "reason": "The finally block is used to execute cleanup code that must run regardless of whether an exception is thrown."
        },
        {
            "question": "Which interface is part of the Java Collections Framework?",
            "choices": ["A. Map", "B. HashCode", "C. Thread", "D. Iterator"],
            "answer": "A",
            "reason": "Map is a core interface in the Java Collections Framework for storing key-value pairs."
        },
        {
            "question": "What is the purpose of using Generics in Java?",
            "choices": ["A. To improve runtime performance", "B. To enable dynamic typing", "C. To allow type-safe operations on various types", "D. To avoid using interfaces"],
            "answer": "C",
            "reason": "Generics enable type-safe operations on various types, allowing for reusable and flexible code."
        },
                {
            "question": "Which file defines project configuration in a Maven project?",
            "choices": ["A. pom.properties", "B. pom.xml", "C. build.gradle", "D. config.yaml"],
            "answer": "B",
            "reason": "Maven uses the POM (Project Object Model), defined in the pom.xml file, to configure the project."
        },
        {
            "question": "What does Maven's dependency management help developers achieve?",
            "choices": ["A. Writing unit tests", "B. Managing transitive dependencies", "C. Improving UI responsiveness", "D. Simplifying database configuration"],
            "answer": "B",
            "reason": "Maven’s dependency management helps automatically resolve and manage transitive dependencies across the project."
        },
        {
            "question": "Which Maven lifecycle phase compiles the source code?",
            "choices": ["A. validate", "B. test", "C. compile", "D. install"],
            "answer": "C",
            "reason": "The compile phase in Maven compiles the project’s source code."
        },
        {
            "question": "In which type of Maven repository are dependencies typically stored on a developer's machine?",
            "choices": ["A. Central", "B. Local", "C. Remote", "D. Cloud"],
            "answer": "B",
            "reason": "A local repository is stored on the developer's machine, typically under ~/.m2/repository."
        },
        {
            "question": "What is a Maven archetype?",
            "choices": ["A. A runtime dependency", "B. A static code analyzer", "C. A project template", "D. A test framework"],
            "answer": "C",
            "reason": "A Maven archetype is a project template used to quickly create pre-configured project structures."
        },
        {
            "question": "In Maven, what does the 'provided' dependency scope mean?",
            "choices": ["A. Dependency used only for unit tests", "B. Dependency available at compile/runtime", "C. Dependency provided by the runtime environment", "D. Dependency only available in production"],
            "answer": "C",
            "reason": "The 'provided' scope means the dependency will be provided by the runtime environment (e.g., servlet container or app server)."
        },
        {
            "question": "Which is a key benefit of using a Multi-Module Maven project?",
            "choices": ["A. Increases build time", "B. Reduces test coverage", "C. Encourages tight coupling", "D. Promotes modularity and separation of concerns"],
            "answer": "D",
            "reason": "A Multi-Module Maven project promotes modularity, separation of concerns, and efficient build management."
        },
        {
            "question": "How is component-based design different from inheritance-based design?",
            "choices": ["A. It uses class hierarchies", "B. It prefers composition over inheritance", "C. It requires multiple inheritance", "D. It avoids using interfaces"],
            "answer": "B",
            "reason": "Component-based design prefers composition over inheritance, resulting in looser coupling and more flexible design."
        },
        {
            "question": "Which concept helps automate component assembly in component-based Java systems?",
            "choices": ["A. Static imports", "B. Dependency Injection frameworks", "C. Singleton pattern", "D. Java Reflection"],
            "answer": "B",
            "reason": "Dependency Injection frameworks (e.g., Spring DI) help automate component assembly and promote loose coupling."
        },
        {
            "question": "In the context of component-based Java design, what is the purpose of the Whiteboard Component Model?",
            "choices": ["A. To implement static method calls", "B. To enable dynamic service registration and decoupling", "C. To replace dependency injection", "D. To enforce compile-time type checks"],
            "answer": "B",
            "reason": "The Whiteboard Component Model enables dynamic service registration and decoupling at runtime, enhancing flexibility."
        },
                {
            "question": "Which of the following is included in JDK but not in JRE?",
            "choices": ["A. JVM", "B. Java core libraries", "C. Development tools like javac", "D. Bytecode interpreter"],
            "answer": "C",
            "reason": "JDK includes JRE + development tools such as the Java compiler (javac), debugger (jdb), and others."
        },
        {
            "question": "Which of the following can be used to achieve multiple inheritance in Java?",
            "choices": ["A. Abstract classes", "B. Interfaces", "C. Regular classes", "D. Final classes"],
            "answer": "B",
            "reason": "Java does not support multiple inheritance with classes, but it can be achieved using interfaces."
        },
        {
            "question": "Which of the following is an advantage of Component-Based Design over Inheritance-Based Design?",
            "choices": ["A. Promotes tight coupling", "B. Reduces reusability", "C. Promotes loose coupling and flexibility", "D. Requires deep class hierarchies"],
            "answer": "C",
            "reason": "Component-Based Design promotes loose coupling and flexibility by favoring composition over inheritance."
        },
        {
            "question": "Compile-time polymorphism is achieved through which mechanism in Java?",
            "choices": ["A. Method overriding", "B. Method overloading", "C. Dynamic dispatch", "D. Interfaces"],
            "answer": "B",
            "reason": "Compile-time polymorphism in Java is achieved through method overloading."
        },
        {
            "question": "Runtime polymorphism is achieved through which mechanism in Java?",
            "choices": ["A. Method overloading", "B. Method overriding", "C. Constructor overloading", "D. Static binding"],
            "answer": "B",
            "reason": "Runtime polymorphism is achieved through method overriding, where the method call is resolved at runtime."
        },
        {
            "question": "Which keyword is used to declare an abstract class in Java?",
            "choices": ["A. static", "B. abstract", "C. interface", "D. final"],
            "answer": "B",
            "reason": "The 'abstract' keyword is used to declare an abstract class in Java."
        },
        {
            "question": "In terms of purpose, how does an Interface differ from an Abstract Class in Java?",
            "choices": ["A. Interfaces cannot have methods", "B. Abstract Classes can only define constants", "C. Interfaces define a contract; Abstract Classes provide partial implementation", "D. Both are used identically in all cases"],
            "answer": "C",
            "reason": "Interfaces define a contract without implementation; Abstract Classes can provide partial implementation."
        },
        {
            "question": "In component assembly, which model emphasizes dynamic service registration at runtime?",
            "choices": ["A. Dependency Injection", "B. Factory pattern", "C. Singleton pattern", "D. Whiteboard Component Model"],
            "answer": "D",
            "reason": "The Whiteboard Component Model emphasizes dynamic service registration and decoupling at runtime."
        },
        {
            "question": "In component assembly, which model emphasizes compile-time wiring of dependencies?",
            "choices": ["A. Whiteboard Component Model", "B. Dependency Injection", "C. Service Locator pattern", "D. Adapter pattern"],
            "answer": "B",
            "reason": "Dependency Injection emphasizes compile-time wiring of dependencies, often supported by DI frameworks such as Spring."
        },
        {
            "question": "Which is more flexible and suitable for designing highly decoupled systems?",
            "choices": ["A. Inheritance-Based Design", "B. Whiteboard Component Model", "C. Static imports", "D. Deep class hierarchy"],
            "answer": "B",
            "reason": "The Whiteboard Component Model enables dynamic registration and decoupling, making it suitable for flexible, highly decoupled systems."
        }
    ],
    "Lecture3: Component-Oriented Design & Architecture": [
        {
            "question": "Which characteristic of CBSE refers to the ability to use a component across multiple systems?",
            "choices": ["A. Modularity", "B. Encapsulation", "C. Reusability", "D. Maintainability"],
            "answer": "C",
            "reason": "Reusability refers to the ability to use components across multiple systems or projects."
        },
        {
            "question": "What is a primary effect of tight coupling?",
            "choices": ["A. Increased flexibility", "B. Easier testing", "C. Harder maintenance", "D. Reduced performance"],
            "answer": "C",
            "reason": "Tight coupling results in less flexibility and makes maintenance and testing more difficult."
        },
        {
            "question": "Loose coupling is commonly achieved using which technique?",
            "choices": ["A. Tight inheritance", "B. Multiple inheritance", "C. Dependency Injection", "D. Static methods"],
            "answer": "C",
            "reason": "Loose coupling is commonly achieved using Dependency Injection, which allows components to depend on interfaces rather than concrete implementations."
        },
        {
            "question": "What does a component with dependency depth 0 indicate?",
            "choices": ["A. It is a user interface component", "B. It has no dependencies", "C. It has one external dependency", "D. It must be recompiled frequently"],
            "answer": "B",
            "reason": "A component with dependency depth 0 has no dependencies."
        },
        {
            "question": "Which type of component dependency allows for greater flexibility at runtime?",
            "choices": ["A. Build-time dependency", "B. Compile-time dependency", "C. Static dependency", "D. Run-time dependency"],
            "answer": "D",
            "reason": "Run-time dependencies allow for more flexible systems since components can be assembled or replaced dynamically at runtime."
        },
        {
            "question": "In Layered Architecture, a common problem is:",
            "choices": ["A. Poor performance", "B. Tight coupling of business logic and UI", "C. Logical layers requiring full redeployment when one layer changes", "D. Inability to add new layers"],
            "answer": "C",
            "reason": "In Layered Architecture, logical layers are often tightly packaged, so redeploying one layer may require redeploying the whole application."
        },
        {
            "question": "What is a key benefit of Layered Component-Based Architecture compared to traditional Layered Architecture?",
            "choices": ["A. Reduced number of components", "B. Improved performance", "C. Components can be replaced independently", "D. Simpler UI design"],
            "answer": "C",
            "reason": "In Layered Component-Based Architecture, components can be replaced independently, providing better flexibility and maintainability."
        },
        {
            "question": "Which pattern uses a central registry for components to look up required services?",
            "choices": ["A. Dependency Injection", "B. Singleton", "C. Service Locator", "D. Factory Method"],
            "answer": "C",
            "reason": "The Service Locator pattern uses a central registry where components can look up required services."
        },
        {
            "question": "Which Java mechanism is used to package and distribute Java components?",
            "choices": ["A. WAR files", "B. JARs and Packages", "C. EAR files", "D. Docker containers"],
            "answer": "B",
            "reason": "JARs (Java ARchive files) and Packages are used to package and distribute Java components."
        },
        {
            "question": "What does a Provided Interface define in a component?",
            "choices": ["A. Services the component requires", "B. Services the component offers to others", "C. External services used by the component", "D. Services inherited from the parent class"],
            "answer": "B",
            "reason": "A Provided Interface defines the services that the component offers to other components."
        },
        {
            "question": "According to componentization rules, how should Entity classes typically be packaged?",
            "choices": ["A. As standalone components", "B. Inside a UI component", "C. In a shared base library", "D. Inside the database layer"],
            "answer": "C",
            "reason": "Entity classes should be packaged in a shared base library and not as standalone components."
        },
        {
            "question": "In an effective componentization strategy, how should business functionality be exposed?",
            "choices": ["A. By accessing class fields directly", "B. By using public static methods", "C. Through provided interfaces only", "D. Through internal utility classes"],
            "answer": "C",
            "reason": "Business functionality should be exposed through provided interfaces only, following the principle of encapsulation."
        },
        {
            "question": "What is a main purpose of using glue code in component-based design?",
            "choices": ["A. To hardcode dependencies", "B. To bridge runtime dependencies dynamically", "C. To compile multiple components together", "D. To optimize database queries"],
            "answer": "B",
            "reason": "Glue code is used to bridge runtime dependencies dynamically and facilitate loose coupling."
        },
        {
            "question": "Which component assembly model involves injecting dependencies at runtime?",
            "choices": ["A. Singleton", "B. Whiteboard", "C. Service Locator", "D. Dependency Injection"],
            "answer": "D",
            "reason": "Dependency Injection (DI) involves injecting dependencies at runtime, promoting loose coupling."
        },
        {
            "question": "Which component assembly model allows components to publish and consume services dynamically?",
            "choices": ["A. Factory Pattern", "B. Singleton Pattern", "C. Whiteboard Component Model", "D. Service Locator"],
            "answer": "C",
            "reason": "The Whiteboard Component Model allows components to dynamically publish and consume services at runtime."
        },
        {
            "question": "In the context of component interaction, what is a Required Interface?",
            "choices": ["A. Services a component offers", "B. Services a component needs", "C. Services inherited from a parent component", "D. Services provided by the system runtime"],
            "answer": "B",
            "reason": "A Required Interface defines the services that a component needs from other components."
        },
        {
            "question": "What is the purpose of a Port in component-based design?",
            "choices": ["A. To connect a component to the network", "B. To enable physical deployment", "C. To define interaction points for services", "D. To encapsulate internal methods"],
            "answer": "C",
            "reason": "A Port defines an interaction point through which a component can provide or consume services."
        },
        {
            "question": "What do Delegation Connectors do in component-based design?",
            "choices": ["A. Manage memory allocation", "B. Connect ports to internal classes providing services", "C. Replace the need for interfaces", "D. Enable database replication"],
            "answer": "B",
            "reason": "Delegation Connectors connect ports to the internal classes that provide the services exposed through the port."
        },
        {
            "question": "Which is a key difference between Build-time and Run-time component dependencies?",
            "choices": ["A. Build-time dependencies are resolved dynamically", "B. Run-time dependencies can be assembled dynamically", "C. Run-time dependencies require recompilation", "D. Build-time dependencies are only used for testing"],
            "answer": "B",
            "reason": "Run-time dependencies can be dynamically assembled, allowing greater flexibility compared to build-time dependencies."
        },
        {
            "question": "In the POS case study, replacing BillBiz & BillUI demonstrated what key advantage of component-based architecture?",
            "choices": ["A. Improved database security", "B. Enhanced UI responsiveness", "C. Ability to replace components without redeploying the full app", "D. Reduced memory usage"],
            "answer": "C",
            "reason": "Replacing BillBiz & BillUI without redeploying the full app demonstrates the flexibility and modularity of component-based architecture."
        },
        {
            "question": "Which type of coupling makes a system harder to maintain and test?",
            "choices": ["A. Loose coupling", "B. Tight coupling", "C. No coupling", "D. Dynamic coupling"],
            "answer": "B",
            "reason": "Tight coupling makes a system harder to maintain and test because components depend heavily on each other's internal details."
        },
        {
            "question": "Loose coupling can be achieved by depending on which element?",
            "choices": ["A. Concrete classes", "B. Static methods", "C. Interfaces", "D. Inheritance hierarchies"],
            "answer": "C",
            "reason": "Loose coupling is achieved when components depend on interfaces rather than concrete implementations."
        },
        {
            "question": "Which architecture allows components to be replaced independently?",
            "choices": ["A. Layered Architecture", "B. Monolithic Architecture", "C. Layered Component-Based Architecture", "D. Client-Server Architecture"],
            "answer": "C",
            "reason": "Layered Component-Based Architecture maps layers to physical components, allowing components to be replaced independently."
        },
        {
            "question": "In traditional Layered Architecture, what is a common deployment limitation?",
            "choices": ["A. Components cannot be reused", "B. The entire application often needs redeployment if one layer changes", "C. No support for service orientation", "D. No use of interfaces"],
            "answer": "B",
            "reason": "In traditional Layered Architecture, layers are logical and often tightly packaged, requiring full redeployment when one layer changes."
        },
        {
            "question": "Build-time component dependencies are resolved:",
            "choices": ["A. Dynamically at runtime", "B. During application deployment", "C. During source code compilation", "D. After the application is running"],
            "answer": "C",
            "reason": "Build-time dependencies are resolved during source code compilation."
        },
        {
            "question": "Run-time component dependencies allow:",
            "choices": ["A. More rigid component interactions", "B. More flexible and dynamic component assembly", "C. Tighter integration between layers", "D. Compile-time dependency resolution"],
            "answer": "B",
            "reason": "Run-time dependencies allow for flexible and dynamic component assembly, improving adaptability."
        },
        {
            "question": "Which component assembly model involves a central registry used for looking up services?",
            "choices": ["A. Whiteboard Model", "B. Dependency Injection", "C. Service Locator", "D. Factory Pattern"],
            "answer": "C",
            "reason": "The Service Locator pattern uses a central registry to look up and retrieve required services."
        },
        {
            "question": "Which component assembly model allows components to publish and consume services dynamically at runtime?",
            "choices": ["A. Singleton", "B. Dependency Injection", "C. Factory", "D. Whiteboard Component Model"],
            "answer": "D",
            "reason": "The Whiteboard Component Model enables dynamic service publication and consumption at runtime."
        },
        {
            "question": "Dependency Injection primarily provides what benefit?",
            "choices": ["A. Dynamic service registration", "B. Compile-time wiring of dependencies to promote loose coupling", "C. Static dependency resolution", "D. Hard-coded dependency paths"],
            "answer": "B",
            "reason": "Dependency Injection provides compile-time wiring of dependencies, promoting loose coupling and easier testing."
        },
        {
            "question": "Which interface defines services a component requires from others?",
            "choices": ["A. Provided Interface", "B. Implemented Interface", "C. Required Interface", "D. Composite Interface"],
            "answer": "C",
            "reason": "A Required Interface defines the services that a component needs from other components."
        }
    ],
    "Lecture4: JPMS & Service Locator Pattern": [
        {
            "question": "Which principle suggests that each component should have only one responsibility?",
            "choices": ["A. Open-Closed Principle", "B. Interface Segregation Principle", "C. Single Responsibility Principle", "D. Dependency Inversion Principle"],
            "answer": "C",
            "reason": "The Single Responsibility Principle (SRP) suggests that each component should have only one responsibility."
        },
        {
            "question": "What is the primary purpose of the Service Locator Pattern?",
            "choices": ["A. To manage database connections", "B. To create singletons", "C. To return service instances on demand", "D. To log application activity"],
            "answer": "C",
            "reason": "The Service Locator Pattern is used to return service instances on demand, providing centralized access to services."
        },
        {
            "question": "Which Java utility allows dynamic service discovery at runtime and is part of the SPI mechanism?",
            "choices": ["A. Reflection API", "B. ServiceLoader", "C. Singleton", "D. DI Framework"],
            "answer": "B",
            "reason": "ServiceLoader is a built-in utility in Java that allows dynamic service discovery at runtime and is part of the SPI mechanism."
        },
        {
            "question": "Where are service implementations registered when using SPI?",
            "choices": ["A. META-INF/resources", "B. META-INF/config", "C. META-INF/services", "D. META-INF/classes"],
            "answer": "C",
            "reason": "Service implementations are registered in the META-INF/services directory when using SPI."
        },
        {
            "question": "Which is a limitation of ServiceLoader?",
            "choices": ["A. Supports AOP out of the box", "B. Allows constructor injection", "C. No prioritization or lifecycle management", "D. Supports external source loading"],
            "answer": "C",
            "reason": "ServiceLoader has limitations including no prioritization of services, no lifecycle management, and limited support for complex dependency injection."
        },
        {
            "question": "What is the primary purpose of the Java Platform Module System (JPMS)?",
            "choices": ["A. Provide a new garbage collector", "B. Replace reflection with annotations", "C. Provide modularization of Java applications", "D. Eliminate the need for ServiceLoader"],
            "answer": "C",
            "reason": "JPMS provides modularization of Java applications and the JDK itself, solving various dependency and packaging issues."
        },
        {
            "question": "Which keyword in module-info.java is used to declare required modules?",
            "choices": ["A. provides", "B. uses", "C. requires", "D. exports"],
            "answer": "C",
            "reason": "The requires keyword in module-info.java declares required modules."
        },
        {
            "question": "Which JPMS keyword allows runtime reflection on a package?",
            "choices": ["A. uses", "B. requires", "C. provides", "D. opens"],
            "answer": "D",
            "reason": "The opens keyword allows runtime reflection on a package, which is used by some frameworks."
        },
        {
            "question": "Which problem is NOT addressed by JPMS?",
            "choices": ["A. Classpath Hell", "B. Lack of encapsulation", "C. Large monolithic JDK", "D. Network latency issues"],
            "answer": "D",
            "reason": "JPMS addresses Classpath Hell, lack of encapsulation, and large JDK issues, but it does not address network latency."
        },
        {
            "question": "How does a Module differ from a Component?",
            "choices": ["A. Module focuses on UI design", "B. Component manages code dependencies", "C. Module handles code organization and dependencies, Component focuses on behavior and functionality", "D. They are always the same"],
            "answer": "C",
            "reason": "A Module handles code organization and dependencies, while a Component focuses on behavior and functionality (e.g. UI, business logic)."
        },
        {
            "question": "What JPMS benefit directly addresses the problem of 'Classpath Hell'?",
            "choices": ["A. Smaller runtime", "B. Enhanced reflection", "C. Strong encapsulation", "D. Better dependency management"],
            "answer": "D",
            "reason": "JPMS provides better dependency management, which helps solve the issue of 'Classpath Hell' by making dependencies explicit and modular."
        },
        {
            "question": "What JPMS feature allows the creation of smaller custom Java runtimes?",
            "choices": ["A. module-info.java", "B. jlink", "C. jmod", "D. jpackage"],
            "answer": "B",
            "reason": "jlink allows the creation of smaller, custom Java runtimes using JPMS modules."
        },
        {
            "question": "Which ServiceLoader limitation can cause an application to silently fail to load a service?",
            "choices": ["A. No exception if service missing", "B. No lifecycle management", "C. No constructor injection", "D. No support for AOP"],
            "answer": "A",
            "reason": "ServiceLoader returns an empty iterator if a service is missing, without throwing an exception — this can cause silent failures."
        },
        {
            "question": "ServiceLoader is best suited for which kind of architecture?",
            "choices": ["A. Monolithic apps", "B. Real-time embedded systems", "C. Plugin-based architectures", "D. Microservices"],
            "answer": "C",
            "reason": "ServiceLoader is ideal for plugin-based architectures where dynamic service discovery is needed."
        },
        {
            "question": "Which mechanism supports automatic dependency injection and lifecycle management?",
            "choices": ["A. ServiceLoader", "B. Service Locator", "C. DI frameworks (e.g. Spring)", "D. META-INF/services"],
            "answer": "C",
            "reason": "DI frameworks such as Spring provide automatic dependency injection and lifecycle management."
        },
        {
            "question": "What is the key difference between Service Locator and Dependency Injection?",
            "choices": ["A. Service Locator supports AOP", "B. Dependency Injection is pull-based, Service Locator is push-based", "C. Service Locator requires manual lookup, DI provides automatic injection", "D. There is no difference"],
            "answer": "C",
            "reason": "Service Locator requires manual lookup of services, while Dependency Injection automatically injects dependencies into components."
        },
        {
            "question": "What is a key difference between Module and Component in Java architecture?",
            "choices": ["A. Modules handle UI logic", "B. Components manage memory", "C. Modules manage code organization and dependencies, Components focus on functionality", "D. Modules and Components are the same thing in Java"],
            "answer": "C",
            "reason": "Modules manage code organization and dependencies, while Components focus on behavior and functionality such as UI or business logic."
        },
        {
            "question": "Which problem did JPMS help solve compared to the traditional Java classpath?",
            "choices": ["A. Database connection pooling", "B. Global transaction management", "C. Lack of compile-time dependency verification", "D. UI theming"],
            "answer": "C",
            "reason": "JPMS helps solve the problem of lack of compile-time dependency verification, which was a weakness of the traditional Java classpath."
        },
        {
            "question": "Which JPMS keyword declares a service dependency in module-info.java?",
            "choices": ["A. provides", "B. exports", "C. requires", "D. uses"],
            "answer": "D",
            "reason": "The uses keyword declares a service dependency in module-info.java."
        },
        {
            "question": "Which is a PRO of using ServiceLoader?",
            "choices": ["A. No lifecycle management", "B. Built-in to Java, no third-party framework required", "C. Full support for constructor injection", "D. Guarantees service order"],
            "answer": "B",
            "reason": "A key advantage of ServiceLoader is that it is built-in to Java and does not require any third-party framework to use."
        },
        {
            "question": "Which mechanism provides automatic injection of dependencies?",
            "choices": ["A. ServiceLocator", "B. ServiceLoader", "C. Dependency Injection (DI)", "D. Manual Constructor Calls"],
            "answer": "C",
            "reason": "Dependency Injection (DI) automatically injects dependencies, typically managed by a framework like Spring."
        },
        {
            "question": "Which mechanism requires manual service lookup in a central registry?",
            "choices": ["A. ServiceLoader", "B. Dependency Injection", "C. Service Locator", "D. Reflection"],
            "answer": "C",
            "reason": "The Service Locator pattern requires components to manually look up services from a central registry."
        },
        {
            "question": "Which mechanism uses the META-INF/services directory for service registration?",
            "choices": ["A. Service Locator", "B. ServiceLoader", "C. Dependency Injection", "D. Reflection API"],
            "answer": "B",
            "reason": "ServiceLoader uses the META-INF/services directory to register service implementations."
        },
        {
            "question": "Which mechanism is most suitable for plugin-based architectures?",
            "choices": ["A. Dependency Injection", "B. ServiceLocator", "C. Factory Pattern", "D. ServiceLoader"],
            "answer": "D",
            "reason": "ServiceLoader is ideal for plugin-based architectures that require dynamic service discovery."
        },
        {
            "question": "In Java architecture, which is the focus of a Module?",
            "choices": ["A. Defining business functionality", "B. Managing code organization and dependencies", "C. Implementing UI design", "D. Managing user sessions"],
            "answer": "B",
            "reason": "A Module focuses on managing code organization and dependencies in a Java system."
        },
        {
            "question": "In Java architecture, which is the focus of a Component?",
            "choices": ["A. Code packaging and distribution", "B. Handling JVM memory", "C. Defining behavior and functionality such as UI or business logic", "D. Managing modules"],
            "answer": "C",
            "reason": "A Component focuses on behavior and functionality — such as UI elements, business logic, or services."
        },
        {
            "question": "Which problem did JPMS directly address compared to the traditional Java classpath?",
            "choices": ["A. Lack of thread management", "B. No compile-time dependency verification", "C. No support for web apps", "D. Limited garbage collection"],
            "answer": "B",
            "reason": "JPMS introduced compile-time dependency verification, which the traditional classpath lacked."
        },
        {
            "question": "Which of the following was a problem before JPMS?",
            "choices": ["A. Strong encapsulation", "B. Classpath Hell", "C. Compile-time dependency checks", "D. Smaller custom runtimes"],
            "answer": "B",
            "reason": "Classpath Hell — where conflicting classes on the classpath caused runtime errors — was a major problem before JPMS."
        },
        {
            "question": "Which is a limitation of ServiceLoader?",
            "choices": ["A. Built-in Java support", "B. Easy service prioritization", "C. No lifecycle management", "D. Full support for dependency injection"],
            "answer": "C",
            "reason": "ServiceLoader has limitations such as no lifecycle management or prioritization of loaded services."
        },
        {
            "question": "Which is a key benefit of using JPMS?",
            "choices": ["A. Makes all public classes globally accessible", "B. Increases the size of the Java runtime", "C. Strong encapsulation of modules", "D. Requires external tools to manage modules"],
            "answer": "C",
            "reason": "One of the main benefits of JPMS is strong encapsulation — only explicitly exported packages are visible to other modules."
        }
    ],
    "Lecture5: Dependency Injection & Component Frameworks": [
        {
            "question": "Which type of component framework is designed to be reusable across different domains?",
            "choices": ["A. Vertical Component Framework", "B. Horizontal Component Framework", "C. Domain-specific Framework", "D. Legacy Framework"],
            "answer": "B",
            "reason": "A Horizontal Component Framework is designed to be reusable across different domains and is loosely coupled."
        },
        {
            "question": "Which type of component composition requires recompilation and redeployment when changes are made?",
            "choices": ["A. Dynamic Component Composition", "B. Runtime Composition", "C. Static Component Composition", "D. Loose Composition"],
            "answer": "C",
            "reason": "Static Component Composition is integrated at compile-time/build-time and requires recompilation and redeployment when changes occur."
        },
        {
            "question": "In which type of component composition is the internal logic completely hidden?",
            "choices": ["A. White-box Composition", "B. Black-box Composition", "C. Gray-box Composition", "D. Hybrid Composition"],
            "answer": "B",
            "reason": "In Black-box Composition, the internal logic is completely hidden and interaction happens through well-defined interfaces."
        },
        {
            "question": "Which type of Java component model defines lifecycle management and component communication mechanisms?",
            "choices": ["A. Factory Pattern", "B. Component Model", "C. Singleton Pattern", "D. MVC Model"],
            "answer": "B",
            "reason": "A Component Model defines lifecycle management, communication mechanisms, and composition rules for components."
        },
        {
            "question": "Which EJB type is used for asynchronous processing?",
            "choices": ["A. Stateless Session Bean", "B. Stateful Session Bean", "C. Message-Driven Bean", "D. Entity Bean"],
            "answer": "C",
            "reason": "Message-Driven Beans are used for asynchronous processing in the EJB architecture."
        },
        {
            "question": "Which is a major problem with traditional EJBs in the context of modern microservices architecture?",
            "choices": ["A. Too lightweight", "B. Requires no server", "C. Heavyweight and requires a full EE-compliant server", "D. Cannot use transactions"],
            "answer": "C",
            "reason": "Traditional EJBs are heavyweight and require a full EE-compliant server, making them unsuitable for modern lightweight microservices."
        },
        {
            "question": "What does Inversion of Control (IoC) primarily promote?",
            "choices": ["A. Tight coupling", "B. Loose coupling and modularity", "C. Direct control by the main program", "D. Strong inheritance hierarchies"],
            "answer": "B",
            "reason": "IoC promotes loose coupling and modularity by letting the framework control the program flow."
        },
        {
            "question": "Which type of Dependency Injection is best suited for mandatory dependencies?",
            "choices": ["A. Interface Injection", "B. Setter Injection", "C. Constructor Injection", "D. Field Injection"],
            "answer": "C",
            "reason": "Constructor Injection is best for mandatory dependencies, ensuring they are provided when the object is created."
        },
        {
            "question": "Which type of Dependency Injection is best used for optional dependencies?",
            "choices": ["A. Constructor Injection", "B. Setter Injection", "C. Field Injection", "D. Reflection Injection"],
            "answer": "B",
            "reason": "Setter Injection is typically used for optional dependencies, allowing them to be set after object construction."
        },
        {
            "question": "What is the main purpose of the Decorator Design Pattern?",
            "choices": ["A. Replace inheritance", "B. Add responsibilities to objects at runtime", "C. Simplify code generation", "D. Eliminate object dependencies"],
            "answer": "B",
            "reason": "The Decorator Design Pattern adds responsibilities to objects at runtime, promoting flexibility through composition."
        },
        {
            "question": "Which of the following violates the Liskov Substitution Principle (LSP)?",
            "choices": ["A. Subclass uses same method signatures as superclass", "B. Subclass weakens postconditions", "C. Subclass is interchangeable with superclass", "D. Subclass preserves behavioral consistency"],
            "answer": "B",
            "reason": "Weakening postconditions in a subclass violates the Liskov Substitution Principle, which requires behavioral consistency."
        },
        {
            "question": "Which type of Dependency Injection is least commonly used and typically framework-specific?",
            "choices": ["A. Constructor Injection", "B. Setter Injection", "C. Interface Injection", "D. Field Injection"],
            "answer": "C",
            "reason": "Interface Injection is less commonly used and is typically found in specific frameworks rather than general practice."
        },
        {
            "question": "Which framework is considered a modern lightweight alternative to EJB?",
            "choices": ["A. CORBA", "B. Spring Framework", "C. Java EE", "D. COM"],
            "answer": "B",
            "reason": "Spring Framework is a modern lightweight component model and Dependency Injection framework that offers an alternative to the heavier EJB model."
        },
        {
            "question": "Which term describes a framework controlling the program flow instead of the developer writing main flow logic?",
            "choices": ["A. Factory Pattern", "B. Inversion of Control (IoC)", "C. Singleton Pattern", "D. Prototype Pattern"],
            "answer": "B",
            "reason": "Inversion of Control (IoC) describes the principle where a framework controls the program flow instead of the developer writing main flow logic."
        },
        {
            "question": "Which type of component composition allows components to be loaded or changed at runtime?",
            "choices": ["A. Static Component Composition", "B. Dynamic Component Composition", "C. Black-box Composition", "D. Tight Component Composition"],
            "answer": "B",
            "reason": "Dynamic Component Composition allows components to be loaded or changed at runtime, improving adaptability."
        },
        {
            "question": "In which type of composition is the internal logic both visible and modifiable?",
            "choices": ["A. Black-box Composition", "B. Gray-box Composition", "C. White-box Composition", "D. Static Composition"],
            "answer": "C",
            "reason": "White-box Composition exposes and allows modification of the internal logic of the component."
        },
        {
            "question": "Which type of component composition is a mix of Black-box and White-box, exposing some metadata or extensions?",
            "choices": ["A. Static Composition", "B. Dynamic Composition", "C. Gray-box Composition", "D. White-box Composition"],
            "answer": "C",
            "reason": "Gray-box Composition is a mix of Black-box and White-box, exposing some metadata or extension points for flexibility."
        },
        {
            "question": "What is a key difference between EJB and Spring Framework?",
            "choices": ["A. EJB is lightweight; Spring is heavyweight", "B. Spring supports DI and is lightweight; EJB requires full EE container", "C. Both require EE container", "D. EJB supports AOP natively, Spring does not"],
            "answer": "B",
            "reason": "Spring Framework supports DI and is lightweight, whereas EJB requires a full EE-compliant container and is heavier."
        },
        {
            "question": "What is the relationship between IoC and DI?",
            "choices": ["A. DI is an implementation of IoC", "B. IoC is a type of DI", "C. They are unrelated", "D. DI replaces IoC"],
            "answer": "A",
            "reason": "Dependency Injection (DI) is a specific implementation of the Inversion of Control (IoC) principle."
        },
        {
            "question": "Which type of injection is best when dependency values must always be provided during object creation?",
            "choices": ["A. Interface Injection", "B. Setter Injection", "C. Constructor Injection", "D. Field Injection"],
            "answer": "C",
            "reason": "Constructor Injection is used when dependency values must always be provided during object creation."
        },
        {
            "question": "Which type of component composition allows components to be changed at runtime without redeploying the application?",
            "choices": ["A. Static Component Composition", "B. Dynamic Component Composition", "C. Black-box Composition", "D. Tight Component Composition"],
            "answer": "B",
            "reason": "Dynamic Component Composition allows components to be changed at runtime, making the system more adaptable."
        },
        {
            "question": "Which type of component composition requires recompilation and redeployment when components change?",
            "choices": ["A. Black-box Composition", "B. Gray-box Composition", "C. Static Component Composition", "D. Dynamic Component Composition"],
            "answer": "C",
            "reason": "Static Component Composition integrates components at build-time, requiring recompilation and redeployment when changes occur."
        },
        {
            "question": "In which type of composition is the internal logic of components completely hidden?",
            "choices": ["A. White-box Composition", "B. Black-box Composition", "C. Gray-box Composition", "D. Hybrid Composition"],
            "answer": "B",
            "reason": "In Black-box Composition, the internal logic is completely hidden, and components interact via defined interfaces."
        },
        {
            "question": "Which type of composition allows partial visibility and extensibility via metadata or extensions?",
            "choices": ["A. Black-box Composition", "B. Gray-box Composition", "C. White-box Composition", "D. Dynamic Composition"],
            "answer": "B",
            "reason": "Gray-box Composition allows partial visibility through metadata or extensions, combining aspects of Black-box and White-box composition."
        },
        {
            "question": "Which framework is considered lightweight and supports Dependency Injection out of the box?",
            "choices": ["A. EJB", "B. Spring Framework", "C. Java EE", "D. CORBA"],
            "answer": "B",
            "reason": "Spring Framework is lightweight and provides built-in support for Dependency Injection (DI)."
        },
        {
            "question": "Which component model requires a full Java EE-compliant server and is considered heavyweight?",
            "choices": ["A. Spring Framework", "B. MicroProfile", "C. EJB", "D. OSGi"],
            "answer": "C",
            "reason": "EJB (Enterprise JavaBeans) requires a full EE-compliant server and is considered heavyweight compared to Spring Framework."
        },
        {
            "question": "Which term refers to the design principle where a framework controls the program flow instead of the developer?",
            "choices": ["A. Dependency Injection", "B. Inversion of Control", "C. Liskov Substitution Principle", "D. Singleton Pattern"],
            "answer": "B",
            "reason": "Inversion of Control (IoC) is the design principle where a framework, not the developer, controls the program flow."
        },
        {
            "question": "What is the relationship between IoC and Dependency Injection?",
            "choices": ["A. IoC is implemented through Dependency Injection", "B. DI is implemented through IoC", "C. They are unrelated", "D. DI replaces IoC entirely"],
            "answer": "A",
            "reason": "IoC is implemented through Dependency Injection; DI is one way to achieve Inversion of Control."
        },
        {
            "question": "Violating the Liskov Substitution Principle typically results in:",
            "choices": ["A. Better modularity", "B. Stronger encapsulation", "C. Unexpected behavior when substituting subclasses", "D. Better inheritance hierarchies"],
            "answer": "C",
            "reason": "Violating LSP leads to unexpected behavior when substituting subclasses in place of their superclasses."
        },
        {
            "question": "Which type of Dependency Injection is most suitable for providing mandatory dependencies at object creation?",
            "choices": ["A. Setter Injection", "B. Interface Injection", "C. Constructor Injection", "D. Field Injection"],
            "answer": "C",
            "reason": "Constructor Injection is most suitable for providing mandatory dependencies during object creation, ensuring they are always available."
        }
    ]
}